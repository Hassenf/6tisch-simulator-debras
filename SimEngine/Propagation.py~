#!/usr/bin/python
'''
\brief Wireless propagation model.

\author Thomas Watteyne <watteyne@eecs.berkeley.edu>
\author Kazushi Muraoka <k-muraoka@eecs.berkeley.edu>
\author Nicola Accettura <nicola.accettura@eecs.berkeley.edu>
\author Xavier Vilajosana <xvilajosana@eecs.berkeley.edu>
'''

#============================ logging =========================================

import logging
class NullHandler(logging.Handler):
    def emit(self, record):
        pass
log = logging.getLogger('Propagation')
log.setLevel(logging.DEBUG)
log.addHandler(NullHandler())

#============================ imports =========================================

import threading
import random
import math
#emunicio
import operator

import Topology
import SimSettings
import SimEngine

#============================ defines =========================================

#============================ body ============================================

class Propagation(object):
    
    #===== start singleton
    _instance      = None
    _init          = False
    
    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(Propagation,cls).__new__(cls, *args, **kwargs)
        return cls._instance
    #===== end singleton
    
    def __init__(self):
        
        #===== start singleton
        # don't re-initialize an instance (needed because singleton)
        if self._init:
            return
        self._init = True
        #===== end singleton
        
        # store params
        self.settings                  = SimSettings.SimSettings()
        self.engine                    = SimEngine.SimEngine()
        
        # variables
        self.dataLock                  = threading.Lock()
        self.receivers                 = [] # motes with radios currently listening
        self.transmissions             = [] # ongoing transmissions
        #random.seed(5)
        # schedule propagation task
        self._schedule_propagate()
    
    def destroy(self):
        self._instance                 = None
        self._init                     = False
    
    #======================== public ==========================================
    
    #===== communication
    
    def startRx(self,mote,channel):
        ''' add a mote as listener on a channel'''
        with self.dataLock:
            self.receivers += [{
                'mote':                mote,
                'channel':             channel,
            }]
    
    def startTx(self,channel,type,smac,dmac,payload):
        ''' add a mote as using a channel for tx'''
        with self.dataLock:
            self.transmissions  += [{
                'channel':             channel,
                'type':                type,
                'smac':                smac,
                'dmac':                dmac,
                'payload':             payload,
            }]
    
    def propagate(self):
        ''' Simulate the propagation of pkts in a slot. '''
        
        with self.dataLock:
            
            asn   = self.engine.getAsn()
            ts    = asn%self.settings.slotframeLength
            
            arrivalTime = {}
            
#            for transmission in self.transmissions:
#                print "Transmissions: From "+str(transmission['smac'].id)+" at "+str((ts,transmission['channel']))
#                print "Will be received by: "
#                if type(transmission['dmac']) == type(transmission['smac']):
#                   print transmission['dmac'].id 
#                else:      
#                    for recv in transmission['dmac']:
#                        print recv.id
            
            # store arrival times of transmitted packets 
            for transmission in self.transmissions:
                if transmission['smac'].id != 0:
                    arrivalTime[transmission['smac']] = transmission['smac'].clock_getOffsetToDagRoot()
                else:
                    arrivalTime[transmission['smac']] = self.engine.getAsn()
                    #print "No need to get offset, i am root"
                #print "Transmission up: "+str(transmission)+" at: "+str(ts)
                     
            #print "In TS="+str(ts)+" I have these tramission scheduled: "+str(self.transmissions)
#            broadcastTransmissions=[]
#            for transmission in self.transmissions:
#                if transmission['type']=='SIXP_TYPE_MYSCHEDULE':
#                    broadcastTransmissions.append(transmission)
#            normalTransmissions=[]
#            for transmission in self.transmissions:
#                if transmission['type']=='TRAFFICOMIO':
#                    normalTransmissions.append(transmission)        
            #print "In TS="+str(ts)+" I have these broadcast tramission scheduled: "+str(broadcastTransmissions)
            #print "In TS="+str(ts)+" I have these normal tramission scheduled: "+str(normalTransmissions)
            
            #return [(ts,c['ch'],c['neighbor']) for ((ts,ch),c) in self.schedule.items() if c['dir']==self.DIR_SHARED]  
   
            
            sortedTransmissionByChannel=[]
            for i in range(0,self.settings.numChans):
                for transmission in self.transmissions:
                    #print "Trnamission has channel "+str(transmission['channel'])+" and i "+str(i)
                    if transmission['channel']==i:
                        sortedTransmissionByChannel.append(transmission)
#            for transmission in sortedTransmissionByChannel:
#                if 'SIXP_TYPE_MYSCHEDULE' != transmission['type']:
#                    print "Propagating in ts "+str(ts)+" and channel "+str(transmission['channel'])+" from "+str(transmission['smac'].id)+" to "+str(transmission['dmac'].id)+" at "+str(self.engine.asn)
#          
            for transmission in sortedTransmissionByChannel:
                
                i           = 0 # index of a receiver
                isACKed     = False
                isNACKed    = False
#                if (ts==47):
#                    print "Propagating in ts "+str(ts)+" and channel "+str(transmission['channel'])+" from "+str(transmission['smac'].id)+" to "+str(transmission['dmac'].id)
                if 'SIXP_TYPE_MYSCHEDULE' == transmission['type']:
                    #print "Mote "+str(transmission['smac'].id)+" has sent a packet at "+str((ts,transmission['channel']))+". It has been received by: "  
                    #for n in transmission['dmac']:
                        #print n.id
                    
                    while i<len(self.receivers):
                        if self.receivers[i]['channel']==transmission['channel']:
                            # this receiver is listening on the right channel
                            #print "Mote "+str(transmission['smac'].id) 
                            #print "Receivers1 "+str(self.receivers[i]['mote'].id)
                            #print "Receivers2 "+str(transmission['dmac'])
                            #print "Transmission from: "+str(transmission['smac'].id)+" for "+str(transmission['dmac'][i])    
                            #for broadcastNeigbhor in transmission['dmac']:
                            #print "Neighbor "+str(broadcastNeigbhor.id)+" has received a broadcast. I am "
                            # other transmissions on the same channel?
                            interferers = [t['smac'] for t in self.transmissions if (t!=transmission) and (t['channel']==transmission['channel'])]
                            
                            interferenceFlag = 0
                            for itfr in interferers:
                                #print "RSSI between "+str(itfr.id)+" and "+str(transmission['smac'])+" is "+str(transmission['smac'].getRSSI(itfr))
                               
                                if self.receivers[i]['mote'].getRSSI(itfr) >self.receivers[i]['mote'].minRssi:
                                    interferenceFlag = 1
                            
                            #transmission['smac'].schedule[(ts,transmission['channel'])]['debug_interference'] += [interferenceFlag] # debug only
                            
                            if interferenceFlag:
                                transmission['smac'].stats_incrementRadioStats('probableCollisions') 
                                #print "BROADCAST! PROBABLY INTERFERENCE IN "+str(ts)+","+str(transmission['channel'])
                            
                            lockOn = transmission['smac']
                            for itfr in interferers:
                                if arrivalTime[itfr] < arrivalTime[lockOn] and self.receivers[i]['mote'].getRSSI(itfr)>self.receivers[i]['mote'].minRssi:
                                    # lock on interference
                                    lockOn = itfr
                            
                            if lockOn == transmission['smac']:
                                # mote locked in the current signal
                                #print "Locked in current signal"
                                transmission['smac'].schedule[(ts,transmission['channel'])]['debug_lockInterference'] += [0] # debug only
                                
                                # calculate pdr, including interference
                                sinr  = self._computeSINR(transmission['smac'],self.receivers[i]['mote'],interferers,True)
                                pdr   = self._computePdrFromSINR(sinr, self.receivers[i]['mote'])
                                
                                                                  
                                
                                # pick a random number
                                failure = random.random() 
#                                print "2PDR "+str(pdr)+" Prob Fail "+str(failure)+" at "+str((ts,transmission['channel'])) 
                                #print self.receivers[i]['mote'].id
#                                print transmission['channel']
#                                print transmission['type']
#                                print transmission
                                if pdr>=failure:
        
                                    isACKed, isNACKed = self.receivers[i]['mote'].radio_rxDone(
                                        type       = transmission['type'],
                                        smac       = transmission['smac'],
                                        dmac       = self.receivers[i]['mote'],
                                        payload    = transmission['payload'],
                                        channel    = transmission['channel']
                                    )                                        
                                    # this mote stops listening
                                    #print "Desired packet is GOOD received in "+str(self.receivers[i]['mote'])
                                    #del self.receivers[i]
                                    
                                else:
                                    # packet is NOT received correctly
                                    #print "Desired packet is not received in "+str(self.receivers[i]['mote'])
                                
                                
#                                    if interferenceFlag:
#                                        self.engine.incrementStatBroadDropByCollision()
#                                        assert False
#                                        print "Detected BROADCAST COLLISION AT "+str((ts,transmission['channel']))+" in mote "+str(self.receivers[i]['mote'].id)+" from mote "+str(transmission['smac'].id)
#                                    
                                    self.receivers[i]['mote'].radio_rxDone(None,None,None,None,transmission['channel'])
                                del self.receivers[i]
                                  
                            else:
                                 #not including broadcast collisions in the stats                                
                                
                                # mote locked in an interfering signal
                                #print "Locked in intefereing signal"
#                                # for debug
#                                transmission['smac'].schedule[(ts,transmission['channel'])]['debug_lockInterference'] += [1]
#                                
#                                # receive the interference as if it's a desired packet
#                                interferers.remove(lockOn)
#                                pseudo_interferers = interferers + [transmission['smac']]
#                                
#                                # calculate SINR where locked interference and other signals are considered S and I+N respectively
#                                pseudo_sinr  = self._computeSINR(lockOn,self.receivers[i]['mote'],pseudo_interferers)
#                                pseudo_pdr   = self._computePdrFromSINR(pseudo_sinr, self.receivers[i]['mote'])
#                                
#                                                               
#                                
#                                # pick a random number
#                                failure = random.random()
                                
                                #print "LOCKED PDR "+str(pseudo_pdr)+" Prob Fail "+str(failure)   
                                #print "3PDR "+str(pseudo_pdr)+" Prob Fail "+str(failure)+" at "+str((ts,transmission['channel']))
                                #if pseudo_pdr>=failure:
                                    # success to receive the interference and realize collision
                                    #not including broadcast collisions
                                    #self.receivers[i]['mote'].schedule[(ts,transmission['channel'])]['rxDetectedCollision'] = True
                                   
                                # desired packet is not received
                                #print "LOCKED Desired packet is not received in "+str(self.receivers[i]['mote'])
                                   
                                
                                self.receivers[i]['mote'].radio_rxDone(None,None,None,None,transmission['channel'])
                                del self.receivers[i]

                        i += 1
                            
                    
#                else:
#                    # this packet is NOT destined for this mote
#                    #print "I am here"
#                    # move to the next receiver
#                    i += 1    
                else:    
                    #print "This is a normal TX"
                    while i<len(self.receivers):
                        
                        if self.receivers[i]['channel']==transmission['channel']:
                            # this receiver is listening on the right channel
                            
                            if self.receivers[i]['mote']==transmission['dmac']:
                                # this packet is destined for this mote
                                #print "Mote "+str(transmission['smac'].id) 
                                                                                       
                                if not self.settings.noInterference:
      
                                    #================ with interference ===========
                                     
                                    # other transmissions on the same channel?
                                    interferers = [t['smac'] for t in self.transmissions if (t!=transmission) and (t['channel']==transmission['channel'])]
                                    
#                                    interferers2 = [t['smac'] for t in self.transmissions if (t!=transmission) and (t['channel']==transmission['channel'])]
#                                    print "Interferers:"
#                                    for t in interferers:
#                                        print t.id
#                                    print "REAL Interferers:"
#                                    for t in interferers2:
#                                        if transmission['dmac'].getRSSI(t)>transmission['dmac'].minRssi:
#                                            print t.id  
                                    
                                    #print "In the channel "+str(transmission['channel'])+" and the ts "+str(ts)+" a there are interferers: "+str(len(interferers))
                                    #print "Propagation in channel "+str(transmission['channel'])+" ts "+str(ts)
#                                    if (ts==5) and transmission['channel']==0:
#                                        print "In the channel "+str(transmission['channel'])+" and the ts "+str(ts)+" a there are interferers: "+str(len(interferers)) 
#                                        for t in self.transmissions:
#                                            print t
                                    
                                    interferenceFlag = 0
                                    for itfr in interferers:
                                        
                                        if transmission['dmac'].getRSSI(itfr)+(-97-(-105))>transmission['dmac'].minRssi:
#                                            if (ts==3 and transmission['channel']==0):
#                                                print "PROP: RSSI from  "+str(transmission['dmac'].id)+" to "+str(itfr.id)+" is "+str(transmission['dmac'].getRSSI(itfr))
#                                                print "PROP: RSSI from  "+str(transmission['smac'].id)+" to "+str(transmission['dmac'].id)+" is "+str(transmission['dmac'].getRSSI(transmission['smac']))
					    #assert False
                                            interferenceFlag = 1
                                            
                                    
                                    transmission['smac'].schedule[(ts,transmission['channel'])]['debug_interference'] += [interferenceFlag] # debug only
                                    
                                    
                                    
                                    if interferenceFlag:
                                        transmission['smac'].stats_incrementRadioStats('probableCollisions') 
                                        #print "PROBABLY INTERFERENCE IN "+str(ts)+","+str(transmission['channel'])
                                    
                                    lockOn = transmission['smac']
                                    for itfr in interferers:
                                        #print transmission['dmac'].getRSSI(itfr)
                                        #print transmission['dmac'].minRssi
                                        if arrivalTime[itfr] < arrivalTime[lockOn] and transmission['dmac'].getRSSI(itfr)>transmission['dmac'].minRssi:
                                            # lock on interference
                                            
                                            lockOn = itfr
                                    
                                    if lockOn == transmission['smac']:
                                        # mote locked in the current signal
                                        
                                        transmission['smac'].schedule[(ts,transmission['channel'])]['debug_lockInterference'] += [0] # debug only
                                        
                                        # calculate pdr, including interference
                                        sinr  = self._computeSINR(transmission['smac'],transmission['dmac'],interferers,False)
                                        pdr   = self._computePdrFromSINR(sinr, transmission['dmac'])
#                                        sinr2  = self._computeSINR(transmission['smac'],transmission['dmac'],interferers,False)
#                                        pdr2   = self._computePdrFromSINR(sinr2, transmission['dmac'])
#                                        print "SINR="+str(sinr)
#                                        print "PDR="+str(pdr)
#                                        print "SINR2="+str(sinr2)
#                                        print "PDR2="+str(pdr2)
                                        
#                                        if (ts==40):
#                                            print "PDR from  "+str(transmission['smac'].id)+" to "+str(transmission['dmac'].id)+" is "+str(pdr)
                                        # pick a random number
                                        failure = random.random() 
                                        #pdr=1
                                        if pdr>=failure:
                                            
                                            #print "Received correctly at "+str((ts,transmission['channel']))+": From "+str(transmission['smac'].id)+" to "+str(transmission['dmac'].id)
                                            #print "The pdr was: "+str(pdr)+" and the sinr was "+str(sinr)
                                            #print "PDR "+str(pdr)+" Prob Fail "+str(failure)
                                            # packet is received correctly                                        
                                            # this mote is delivered the packet
                                            #print "1PDR "+str(pdr)+" Prob Fail "+str(failure)+" at "+str((ts,transmission['channel'])) 
                                            isACKed, isNACKed = self.receivers[i]['mote'].radio_rxDone(
                                                type       = transmission['type'],
                                                smac       = transmission['smac'],
                                                dmac       = transmission['dmac'],
                                                payload    = transmission['payload'],
                                                channel    = transmission['channel']
                                            )  
                                            
                                            # this mote stops listening
                                            del self.receivers[i]
                                            
                                        else: #here does not mean there is a collision. Only means a packet that have a possible interference has failed. but interference flag has not being raised                                                                                                                                 
                                           
                                           # packet is NOT received correctly
#                                            print "---NOT received correctly at "+str((ts,transmission['channel']))+": From "+str(transmission['smac'].id)+" to "+str(transmission['dmac'].id)
#                                            print "The pdr was: "+str(pdr)+" and the sinr was "+str(sinr)
#                                            print "In the channel "+str(transmission['channel'])+" and the ts "+str(ts)+" a there are interferers: "+str(len(interferers))
                                            if interferenceFlag:
#                                                print "There are some REAL interferers: "+str(len(interferers))
#                                                print "In case no interferers: "
#                                                interferers=[]
#                                                sinr  = self._computeSINR(transmission['smac'],transmission['dmac'],interferers,False)
#                                                pdr   = self._computePdrFromSINR(sinr, transmission['dmac'])
#                                                print "The pdr would have been: "+str(pdr)+" and the sinr whould have been "+str(sinr)
#                                                print "----------Detected collision in "+str((ts,transmission['channel']))
                                                self.engine.incrementStatDropByCollision()
                                                #assert False
					    else:
						self.engine.incrementStatDropByPropagation()
                                            self.receivers[i]['mote'].radio_rxDone(None,None,None,None,transmission['channel'])
                                            del self.receivers[i]
                                        
                                    else:
                                        # mote locked in an interfering signal
                                        #assert False
                                        # for debug
                                        transmission['smac'].schedule[(ts,transmission['channel'])]['debug_lockInterference'] += [1]
                                        
                                        # receive the interference as if it's a desired packet
                                        interferers.remove(lockOn)
                                        pseudo_interferers = interferers + [transmission['smac']]
                                        
                                        # calculate SINR where locked interference and other signals are considered S and I+N respectively
                                        pseudo_sinr  = self._computeSINR(lockOn,transmission['dmac'],pseudo_interferers,False)
                                        pseudo_pdr   = self._computePdrFromSINR(pseudo_sinr, transmission['dmac'])
                                        
                                        # pick a random number
                                        failure = random.random()
                                        if pseudo_pdr>=failure:
                                            # success to receive the interference and realize collision
                                            
                                            #print "1Detected collision in "+str((ts,transmission['channel']))
                                            #assert False
                                            transmission['dmac'].schedule[(ts,transmission['channel'])]['rxDetectedCollision'] = True
                                            
                                        # desired packet is not received
                                        self.engine.incrementStatDropByCollision()
                                        self.receivers[i]['mote'].radio_rxDone(None,None,None,None,transmission['channel'])
                                        del self.receivers[i]
                                    
                                else:
                                    
                                    #================ without interference ========
                                    assert False #only interference model
#                                    interferers = []
#                                    
#                                    transmission['smac'].schedule[(ts,transmission['channel'])]['debug_interference']     += [0] # for debug only
#                                    transmission['smac'].schedule[(ts,transmission['channel'])]['debug_lockInterference'] += [0] # for debug only
#                                    
#                                    # calculate pdr with no interference
#                                    sinr  = self._computeSINR(transmission['smac'],transmission['dmac'],interferers)
#                                    pdr   = self._computePdrFromSINR(sinr, transmission['dmac'])
#                                    
#                                    # pick a random number
#                                    failure = random.random()
#                                    
#                                    if pdr>=failure:
#                                        # packet is received correctly
#                                        
#                                        # this mote is delivered the packet
#                                        isACKed, isNACKed = self.receivers[i]['mote'].radio_rxDone(
#                                            type       = transmission['type'],
#                                            smac       = transmission['smac'],
#                                            dmac       = transmission['dmac'],
#                                            payload    = transmission['payload'],
#                                            channel    = transmission['channel']
#                                        )
#                                        
#                                        # this mote stops listening
#                                        del self.receivers[i]
#                                        
#                                    else:
#                                        # packet is NOT received correctly
#                                        
#                                        self.receivers[i]['mote'].radio_rxDone(None,None,None,None,transmission['channel'])
#                                        del self.receivers[i]
                            
     
                            #i += 1    
                        #else:
                            # this receiver is NOT listening on the right channel
                            
                            # move to the next receiver
                        i += 1
                    #print "Packet SENT"
                    # indicate to source packet was sent
                    transmission['smac'].radio_txDone(isACKed, isNACKed)
            
            
            # remaining receivers that does not receive a desired packet
            for r in self.receivers:
                
                if not self.settings.noInterference:
                    
                    #================ with interference ===========
                    #for t in self.transmissions:
                         #print "Transmission down: "+str(t)+" at: "+str(ts)
                    #print "At "+str(ts)+" mote "+str(r['mote'].id)+" with chedule "+str(r['mote'].schedule.keys())
                    #for cell in r['mote'].schedule.keys()
                    #print "At "+str(ts)+" possible collision "+str(len(self.receivers))
                    #print "Receivers: "+str(r['mote'].id)+" at: "+str(ts)
                    interferers = [t['smac'] for t in self.transmissions if t['dmac']!=r['mote'] and t['channel']==r['channel']]
#                    print interferers
#                    print r['channel']
#                    print ts
#                    if ts!=0 and r['channel']!=0:
#                        assert False
                    
#                    if interferers:
#                        for moteInt in interferers:
#                            print "Intereferers: "+str(moteInt.id)+" at: "+str(ts)
                   
                   
                    
                    lockOn = None
                    for itfr in interferers:
                        
                        if not lockOn:
                            if r['mote'].getRSSI(itfr)>r['mote'].minRssi:
                                lockOn = itfr
                        else:
                            if r['mote'].getRSSI(itfr)>r['mote'].minRssi and arrivalTime[itfr]<arrivalTime[lockOn]:
                                lockOn = itfr
                    
                    if lockOn:
                        # pdr calculation
                        
                        # receive the interference as if it's a desired packet
                        interferers.remove(lockOn)
    
                        # calculate SINR where locked interference and other signals are considered S and I+N respectively
                        pseudo_sinr  = self._computeSINR(lockOn,r['mote'],interferers,False)
                        #for moteInt in interferers:
                            #print "Intereferers: "+str(moteInt.id)+" at: "+str(ts)
                        #print "SINR between "+str(r['mote'].id)+" and "+str(lockOn.id)+" is "+str(pseudo_sinr)
                        pseudo_pdr   = self._computePdrFromSINR(pseudo_sinr,r['mote'])
                        
                        # pick a random number
                        failure = random.random()
                        #print "Ran "+str(failure)
                        #print "PSudo "+str(pseudo_pdr)
                        if pseudo_pdr>=failure:
                            for cell in lockOn.schedule.keys():
                                if cell in r['mote'].schedule.keys():
                                    #print "Very Probable collision in "+str(cell)+" At "+str(ts)
                                    if cell[0] == ts:
                                        #print "In this time slot there is a collision "+str(cell)+" At "+str(ts)
                            #print "Detected Collision in some of these cells: "+str(lockOn.schedule.keys())+" At "+str(ts)+" in mote "+str(lockOn.id)
                            #print "Detected Collision in some of these cells: "+str(r['mote'].schedule.keys())+" At "+str(ts)+" in mote "+str(r['mote'].id)
#                                        if ts!=0 and cell[1]!=0:
#                                            print "(receiver) Detected Collision in "+str((cell[0],cell[1]))
#                                            assert False
                                        # success to receive the interference and realize collision
                                        #print "(receiver) Detected Collision in "+str((ts,cell[1]))    
                                        r['mote'].schedule[(ts,cell[1])]['rxDetectedCollision'] = True
                                        
#                                        if ts!=0 and cell[1]!=0:
#                                            print "3Detected collision in "+str((ts,cell[1]))
                                            #assert False
                                        
                                        #assert False
#                            # success to receive the interference and realize collision
#                            r['mote'].schedule[ts]['rxDetectedCollision'] = True
                    
                    # desired packet is not received
                   
                    r['mote'].radio_rxDone(None,None,None,None,r['channel'])
                else: #only model with interference
                    assert False
            # clear all outstanding transmissions
            self.transmissions              = []
            self.receivers                  = []
        #assert False
        self._schedule_propagate()
    
    #======================== private =========================================
    
    def _schedule_propagate(self):
        with self.dataLock:
            self.engine.scheduleAtAsn(
                asn         = self.engine.getAsn()+1,# so propagation happens in next slot
                cb          = self.propagate,
                uniqueTag   = (None,'propagation'),
                priority    = 1,
            )
    
    def _computeSINR(self,source,destination,interferers,broadcast):
        ''' compute SINR  '''
        #print "interferers "+str(interferers)
        #print "Calculating SINR between: "+str(source.id)+" and "+str(destination.id)
        #print "There are interferers: "+str(len(interferers))
        #if (source.getRSSI(destination) < destination.minRssi or destination.getRSSI(source)  < source.minRssi ):
            #print "Not in LOS: "+str(source.id)+" - "+str(destination.id)
            #return -10.0
        #else:
            #print "In LOS: "+str(source.id)+" - "+str(destination.id)
        
#        #this really seems what it makes difference
#        if broadcast==False:
#            for interferer in interferers:   
#                if (destination.getRSSI(interferer)+(-97-(-105)) >= destination.minRssi):
#                    return -10.0

        
            
        
        noise = self._dBmTomW(destination.noisepower)
        # S = RSSI - N
        #print "Noise: "+str(noise)
        signal = self._dBmTomW(source.getRSSI(destination)) - noise
        #print "Signal: "+str(signal)
        if signal < 0.0:
            # RSSI has not to be below noise level. If this happens, return very low SINR (-10.0dB)
            return -10.0
          
        #print "To "+str(destination.id)+"there are noise"+str(destination.noisepower) 
        #print "From "+str(destination.id)+"there are power"+str(source.getRSSI(destination)) 
        #if broadcast==False:
            #print "Using no interferers"
           # sinr = signal/(noise)
            #return self._mWTodBm(sinr)
        #print "Using interferers"
        totalInterference = 0.0
        for interferer in interferers:
            # I = RSSI - N
            
            interference = self._dBmTomW(interferer.getRSSI(destination)) - noise
            #print "Interference from "+str(interferer.id)+" -> "+str(interferer.getRSSI(destination))+" "+str(interference)
            if interference < 0.0:
                # RSSI has not to be below noise level. If this happens, set interference 0.0
                interference = 0.0
            totalInterference += interference
        #print "Total interference "+str(totalInterference)
        sinr = signal/(totalInterference + noise)
#        if source.id==2:
#            print "SINR from "+str(source.id)+" to "+str(destination.id)+" is "+str(self._mWTodBm(sinr))
#        if source.id==26:
#            print "SINR from "+str(source.id)+" to "+str(destination.id)+" is "+str(self._mWTodBm(sinr))
        return self._mWTodBm(sinr)
    
    def _computePdrFromSINR(self, sinr, destination):
        ''' compute PDR from SINR '''

        
#for remove propagation errors       
#        if sinr > 10:
#            return 1
#        else:
#            return 0
        
        
#            print "Destination "+str(destination.id)+" noiepower "+str(destination.noisepower)
#            print "Equivalent RSSI in mW: "+str(self._dBmTomW(sinr+destination.noisepower))+" + "+str(self._dBmTomW(destination.noisepower))
        #print "Equivalent RSSI in dBm: "+str(self._mWTodBm(self._dBmTomW(sinr+destination.noisepower)))+" + "+str(self._mWTodBm(self._dBmTomW(destination.noisepower)))
        equivalentRSSI  = self._mWTodBm(
            self._dBmTomW(sinr+destination.noisepower) + self._dBmTomW(destination.noisepower)
        )
        
        #temporal for no wireless errors   
        #equivalentRSSI=0
        #print "an with noise "+str(equivalentRSSI)
        pdr             = Topology.Topology.rssiToPdr(equivalentRSSI)
#        if destination.id==1:
#            print "SINR "+str(sinr)
#            print "Equivalent RSSI "+str(equivalentRSSI)
#            print "Equivalent PDR "+str(pdr)
#        if destination.id==23:
#            print "SINR "+str(sinr)
#            print "Equivalent RSSI "+str(equivalentRSSI)  
#            print "Equivalent PDR "+str(pdr)
        
        return pdr
    
    def _dBmTomW(self, dBm):
        ''' translate dBm to mW '''
        return math.pow(10.0, dBm/10.0)
    
    def _mWTodBm(self, mW):
        ''' translate dBm to mW '''
        return 10*math.log10(mW)
