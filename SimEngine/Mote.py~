#!/usr/bin/python
'''
\brief Model of a 6TiSCH mote.

\author Thomas Watteyne <watteyne@eecs.berkeley.edu>
\author Kazushi Muraoka <k-muraoka@eecs.berkeley.edu>
\author Nicola Accettura <nicola.accettura@eecs.berkeley.edu>
\author Xavier Vilajosana <xvilajosana@eecs.berkeley.edu>
'''

#============================ logging =========================================

import logging
class NullHandler(logging.Handler):
    def emit(self, record):
        pass
log = logging.getLogger('Mote')
log.setLevel(logging.DEBUG)
log.addHandler(NullHandler())

#============================ imports =========================================

import copy
import random
import threading
import math

import SimEngine
import SimSettings
import Propagation
import Topology

#============================ defines =========================================

#============================ body ============================================

class Mote(object):
    
    # sufficient num. of tx to estimate pdr by ACK
    NUM_SUFFICIENT_TX                  = 10
    # maximum number of tx for history
    NUM_MAX_HISTORY                    = 32
    
    DIR_TX                             = 'TX'
    DIR_RX                             = 'RX'
    DIR_SHARED                         = 'SHARED'
    
    BROAD                              = 'BROADCAST'
    
    DEBUG                              = 'DEBUG'
    INFO                               = 'INFO'
    WARNING                            = 'WARNING'
    ERROR                              = 'ERROR'
    
    #=== app
    APP_TYPE_DATA                      = 'DATA'
    APP_TYPE_MYTRAFFIC                 = 'TRAFFICOMIO'
    SIXP_TYPE_MYSCHEDULE                 = 'SIXP_TYPE_MYSCHEDULE'
    
    #=== rpl
    RPL_PARENT_SWITCH_THRESHOLD        = 384 # corresponds to 1.5 hops. 6tisch minimal draft use 384 for 2*ETX.
    #RPL_PARENT_SWITCH_THRESHOLD        = 768 # corresponds to 1.5 hops. 6tisch minimal draft use 384 for 2*ETX.
    #using minimal draft
    #RPL_PARENT_SWITCH_THRESHOLD        = 386 # corresponds to 1.5 hops. 6tisch minimal draft use 384 for 2*ETX.
    #RPL_MIN_HOP_RANK_INCREASE          = 256
    RPL_MIN_HOP_RANK_INCREASE          =  1536#(256*6)
    #RPL_MIN_HOP_RANK_INCREASE          = 512
    RPL_MAX_ETX                        = 1.3
    RPL_MAX_RANK_INCREASE              = RPL_MAX_ETX*RPL_MIN_HOP_RANK_INCREASE*2 # 4 transmissions allowed for rank increase for parents
    RPL_MAX_TOTAL_RANK                 = 256*RPL_MIN_HOP_RANK_INCREASE*2 # 256 transmissions allowed for total path cost for parents
    RPL_PARENT_SET_SIZE                = 1
    DEFAULT_DIO_INTERVAL_MIN           = 3 # log2(DIO_INTERVAL_MIN), with DIO_INTERVAL_MIN expressed in ms
    DEFAULT_DIO_INTERVAL_DOUBLINGS     = 20 # maximum number of doublings of DIO_INTERVAL_MIN (DIO_INTERVAL_MAX = 2^(DEFAULT_DIO_INTERVAL_MIN+DEFAULT_DIO_INTERVAL_DOUBLINGS) ms)
    DEFAULT_DIO_REDUNDANCY_CONSTANT    = 10 # number of hearings to suppress next transmission in the current interval
    
    #=== otf
    OTF_TRAFFIC_SMOOTHING              = 0.5
    #=== 6top
    #=== tsch
    TSCH_QUEUE_SIZE                    = 10
    TSCH_MAXTXRETRIES                  = 5    
    #=== radio
    RADIO_MAXDRIFT                     = 30 # in ppm
    #=== battery
    # see A Realistic Energy Consumption Model for TSCH Networks.
    # Xavier Vilajosana, Qin Wang, Fabien Chraim, Thomas Watteyne, Tengfei
    # Chang, Kris Pister. IEEE Sensors, Vol. 14, No. 2, February 2014.
    CHARGE_Idle_uC                     = 24.60
    CHARGE_TxDataRxAck_uC              = 64.82
    CHARGE_TxData_uC                   = 49.37
    CHARGE_RxDataTxAck_uC              = 76.90
    CHARGE_RxData_uC                   = 64.65
    
    def __init__(self,id):
        
        self.x=0
        self.y=0        
        
        
        #random.seed(1)        
        
        # store params
        self.id                        = id
        # local variables
        self.dataLock                  = threading.RLock()
        
        self.engine                    = SimEngine.SimEngine()
        self.settings                  = SimSettings.SimSettings()
        self.propagation               = Propagation.Propagation()
        
        # app
        self.pkPeriod                  = self.settings.pkPeriod        
        # role
        self.dagRoot                   = False
        # rpl
        self.rank                      = None
        self.dagRank                   = None
        self.parentSet                 = []
        self.preferredParent           = None
        self.rplRxDIO                  = {}                    # indexed by neighbor, contains int
        self.neighborRank              = {}                    # indexed by neighbor
        self.neighborDagRank           = {}                    # indexed by neighbor
        self.trafficPortionPerParent   = {}                    # indexed by parent, portion of outgoing traffic
        # otf
        self.asnOTFevent               = None
        self.otfHousekeepingPeriod     = self.settings.otfHousekeepingPeriod
        self.timeBetweenOTFevents      = []
        self.inTraffic                 = {}                    # indexed by neighbor
        self.inTrafficMovingAve        = {}                    # indexed by neighbor
        # 6top
        self.numCellsToNeighbors       = {}                    # indexed by neighbor, contains int
        self.numCellsFromNeighbors     = {}                    # indexed by neighbor, contains int
        
        # changing this threshold the detection of a bad cell can be
        # tuned, if as higher the slower to detect a wrong cell but the more prone
        # to avoid churn as lower the faster but with some chances to introduces
        # churn due to unstable medium
        self.sixtopPdrThreshold           = self.settings.sixtopPdrThreshold
        self.sixtopHousekeepingPeriod  = self.settings.sixtopHousekeepingPeriod
        # tsch
        self.txQueue                   = []
        self.pktToSend                 = []                 #list of packets to send in one ts (in different channels)
        self.schedule                  = {}                 # indexed by ts and ch  contains info of the all the channels in each ts 
        self.scheduleNeigborhood       = {}                 # indexed by ts and ch contains the cells used in my neighborhood                    
        
        #self.waitingFor                = None               #not used, usinf sdr
        self.timeCorrectedSlot         = None
        # radio
        self.txPower                   = 0                     # dBm
        self.antennaGain               = 0                     # dBi
        self.minRssi                   = self.settings.minRssi # dBm
        self.noisepower                = -105                  # dBm
        self.drift                     = random.uniform(-self.RADIO_MAXDRIFT, self.RADIO_MAXDRIFT)
        # wireless
        self.RSSI                      = {}                    # indexed by neighbor
        self.PDR                       = {}                    # indexed by neighbor
        # location
        # battery
        self.chargeConsumed            = 0
        
        # stats
        self._stats_resetMoteStats()
        self._stats_resetQueueStats()
        self._stats_resetLatencyStats()
        self._stats_resetHopsStats()
        self._stats_resetRadioStats()
        
        #emunicio
        self.numPacketSent                 = 0 #number of packets sent
      
        self.numPacketReceived             = 0 #number of packets received 
        self.probeNumPacketReceived=0

        self.finishMyFlow                  = False
        self.packetsGenerated              = 0
        self.probePacketsGenerated=0

        self.numReqCells=0
        
        self.myMaxCellDemand=0

        self.numTransmissions=0
        self.numReceptions=0
        
        self.otfTriggered=False      
        
        self.maxWin=None       
        self.numberOfWaitings=None
        self.numBroadCells=0
        self.chosenBroadCell_id=None
        self.myBrTs=None
        self.myBrCh=None
       
        self.hopsToRoot=0
        
        self.threq=0
                                       
        self.numRandomSelections=0
                
        
        #emunicio debug
        self.DEBUG=False       
        self.DEBUGCLEAN=False
        self.ApplyChanges=True

        #print "Intializing node"
        #self._stats_resetMote1secStats()
    #======================== stack ===========================================
    
    #===== role
    
    def role_setDagRoot(self):
        self.dagRoot              = True
        self.rank                 = 0
        self.dagRank              = 0
        self.packetLatencies      = [] # in slots
        self.packetHops           = []
        
    
    #===== application
    #emunicio 
    def _app_schedule_sendSinglePacket(self,firstPacket=False):
        '''
        create an event that is inserted into the simulator engine to send the data according to the traffic
        '''  
        with self.dataLock:
            if not self.finishMyFlow:
                if not firstPacket:
                    # compute random delay
                    delay            = self.pkPeriod*(1+random.uniform(-self.settings.pkPeriodVar,self.settings.pkPeriodVar)) 
                else:
                    # compute initial time within the range of [next asn, next asn+pkPeriod]
                    delay            = self.settings.slotDuration + (self.settings.slotframeLength/6)*random.random() + (self.settings.slotframeLength/6) 
		    # max at 16.9 or 30 seconds and duration of 10 or 100 seconds according the frame length
		    #delay            = self.settings.slotDuration + (self.settings.slotframeLength*0.9)*random.random() + (self.settings.slotframeLength) # max at 9 or 90 seconds and duration of 10 or 100 seconds according the frame length
                    ###!!!### if self.DEBUG: print "I am "+str(self.id)+" Sending first packet at: "+str(delay)
                         
                assert delay>0   
                
#                if (self.engine.asn >= 10100) and self.engine.initTimeStampTraffic==0:
#                    self.engine.initTimeStampTraffic=self.engine.asn*self.settings.slotDuration
                    #print "Sending first packet at: "+str(self.engine.initTimeStampTraffic) 
                
                #if (self.engine.asn < (290*self.settings.slotframeLength)):  #cycle 290
                if (self.engine.asn < (96*self.settings.slotframeLength)):  #cycle 96
                       
                    # schedule
                    self.engine.scheduleIn(
                        delay            = delay,
                        cb               = self._app_action_sendSinglePacket,
                        uniqueTag        = (self.id, '_app_action_sendSinglePacket'),
                        priority         = 2,
                    )
#                else:
#                    if self.engine.endTimeStampTraffic==0:
#                        self.engine.endTimeStampTraffic=self.engine.asn*self.settings.slotDuration
#                        print "Finish at: "+str(self.engine.endTimeStampTraffic)
#                        self.engine.timeElapsedFlow=self.engine.endTimeStampTraffic-self.engine.initTimeStampTraffic
                        
 
    #not used for the moment      
    def _app_schedule_sendPacketBurst(self):
        ''' create an event that is inserted into the simulator engine to send a data burst'''
        print "Preparing packet bursts in "+str(self.id)
        # schedule numPacketsBurst packets at burstTimestamp
        for i in xrange(self.settings.numPacketsBurst):
            self.engine.scheduleIn(
                delay        = self.settings.burstTimestamp,
                cb           = self._app_action_enqueueData,
                uniqueTag    = (self.id, '_app_action_enqueueData_burst1'),
                priority     = 2,
            )
            self.engine.scheduleIn(
                delay        = 3*self.settings.burstTimestamp,
                cb           = self._app_action_enqueueData,
                uniqueTag    = (self.id, '_app_action_enqueueData_burst2'),
                priority     = 2,
            )
        
    
    def _app_action_sendSinglePacket(self):
        ''' actual send data function. Evaluates queue length too '''
        
        
        
        # enqueue data
        #print "Preparing enqueuing..."
        self._app_action_enqueueData()
        
        # schedule next _app_action_sendSinglePacket
        self._app_schedule_sendSinglePacket()
    
    def _app_action_enqueueData(self):
        ''' enqueue data packet into stack '''
                      
        #print "Sending packet at: "
        self._stats_incrementMoteStats('appGenerated')
        self.packetsGenerated+=1   

        self.threq=self.hopsToRoot     
        if (self.engine.asn < (96*self.settings.slotframeLength)) and (self.engine.asn > (63*self.settings.slotframeLength)): #excel 97-131
	#if (self.engine.asn < (290*self.settings.slotframeLength)) and (self.engine.asn > (190*self.settings.slotframeLength)): #excel 191-292
            self.probePacketsGenerated+=1

        # only start sending data if I have some TX cells
        if self.getTxCells():
            newPacket = {
                'asn':            self.engine.getAsn(),
                'type':           self.APP_TYPE_MYTRAFFIC,
                'payload':        [self.id,self.engine.getAsn(),1], # the payload is used for latency and number of hops calculation
                'retriesLeft':    self.TSCH_MAXTXRETRIES
            }
            
            #emunicio
            #if self.pktToSend['type'] == self.APP_TYPE_MYTRAFFIC:
            #if self.id==24:
            self.numPacketSent+=1                    
            #self.numPacketSent1sec=self.numPacketSent1sec+1
                      
            # enqueue packet in TSCH queue
            isEnqueued = self._tsch_enqueue(newPacket)
            
            if isEnqueued:
                # increment traffic
                #if self.id==24:
                    #print "Packet enqueued in node "+str(self.id)
                    #print "Packet enqueued in node "+str(self.id)+" my queue is "+str(len(self.txQueue))+" and my parent is "+str(self.parentSet[0].id)
                self._otf_incrementIncomingTraffic(self)
            else:
                #if self.id==24:
                self._stats_incrementMoteStats('droppedAppFailedEnqueue')
                #print "queue is full"
                #print "Packet not enqueued in node "+str(self.id)+" my queue is "+str(len(self.txQueue))+" and my parent is "+str(self.parentSet[0].id)
        else:
            #if self.DEBUG: print "no TX cells in node "+str(self.id)
#            if self.id==24:
            self._stats_incrementMoteStats('droppedAppFailedEnqueue')
                
            self._stats_incrementMoteStats('droppedNoTxCells')
            # update mote stats
#            print "Mote "+str(self.id)+" No TX CELLS but:"+ str(self.getTxCells())
#            for ((ts,ch),item) in self.schedule.items(): 
#                print "Cell "+str((item['ts'],item['ch']))+"Dir "+str(item['dir'])+" to neighbor "+str(item['neighbor'])
                #print "Mote "+str(self.id)+" has no TX cells: "+str(self.getTxCells())+" to his parent. Schedule: "+str(self.schedule.keys())
            
    
    #===== rpl
    
    def _rpl_schedule_sendDIO(self,firstDIO=False):
        
        with self.dataLock:

            asn    = self.engine.getAsn()
            ts     = asn%self.settings.slotframeLength
            
            if not firstDIO:
                
                cycle = int(math.ceil(self.settings.dioPeriod/(self.settings.slotframeLength*self.settings.slotDuration)))
                #print "Cycle "+str(cycle)+' '+str(self.settings.dioPeriod)+' '+str(self.settings.slotframeLength)
            else:
                cycle = 1 
            
             ###!!!### if self.DEBUG: print "I am "+str(self.id)+" at "+str(self.engine.asn)+" Scheduling dio at "+str(asn-ts+cycle*self.settings.slotframeLength)+" my rank and dagrank is "+str(self.rank)+" "+str(self.dagRank)
            if self.preferredParent != None:
               
                 ###!!!### if self.DEBUG: print "I am "+str(self.id)+" and my preferred parent is "+str(self.preferredParent.id)
                #if self.preferredParent.preferredParent:
                 ###!!!### if self.DEBUG: print "The preferred parent of "+str(self.preferredParent.id)+" and my preferred parent is "+str(self.preferredParent.preferredParent.id)
                 ###!!!### if self.DEBUG: print "my rank and dagrank is "+str(self.rank)+" "+str(self.dagRank)
                
                self.hopsToRoot=self.recalculateNumHopsToRoot()
                #print "I am from root at: "+str(self.hopsToRoot)
                if self.id!=0 and self.otfTriggered != True:
                    self._otf_schedule_housekeeping(firstOtf=True)
                    self.otfTriggered=True
            else:
                                                
                if self.engine.asn> (10*self.settings.slotframeLength) and self.id!=0:
                    print "I DONT HAVE PARENT-----------------------------------------------------------------------------------------------"
                    print "I am "+str(self.id)+" and my parent is "+str(self.preferredParent)+" I am lost my parent!!!!!!!!!!!!!!!!!!!!!!!!!!!!!111"
                    print "I am "+str(self.id)+" and I dont have preferred parent"
                    print "my rank and dagrank is "+str(self.rank)+" "+str(self.dagRank)
                    assert False
            # schedule at start of next cycle
            self.engine.scheduleAtAsn(
                asn         = asn-ts+cycle*self.settings.slotframeLength,
                cb          = self._rpl_action_sendDIO,
                uniqueTag   = (self.id,'_rpl_action_sendDIO'),
                priority    = 3,
            )
    
    def _rpl_action_sendDIO(self):
        
        with self.dataLock:
#            #if not self.dagRoot:
            #print "I am "+str(self.id)+" I have neighbors: "+str(len(self._myNeigbors()))
            #print "my rank and dagrank is "+str(self.rank)+" "+str(self.dagRank)
#                #for neigh in self._myNeigbors():
#                #    print "Neighbor: "+str(neigh.id)+" has rank "+str(neigh.rank)
#            if self.id==34:
#                print "My prefered parent is: "+str(self.preferredParent.id)+" he has rank "+str(self.preferredParent.rank) +" at asn "+str(self.engine.getAsn())
#                for parent1 in self.parentSet:
#                    print "One possible parent is: "+str(parent1.id)
#                for neigh1 in self.neighborRank.keys():
#                    print "Neighbor  "+str(neigh1.id)+" has rank "+str(self.neighborRank[neigh1])+" and dag rank "+str(self.neighborDagRank[neigh1])
        
            
            
            
            
            if self.rank!=None and self.dagRank!=0 or self.dagRoot==True:
                 ###!!!### if self.DEBUG: print "Mote "+str(self.id)+" Sends DIO at "+str(self.engine.asn)+" DAGRANK "+str(self.dagRank)
#                if self.preferredParent:
#                    print "I am "+str(self.id)+" My parent is "+str(self.preferredParent.id)+" my rank is "+str(self.rank)
                # update mote stats
                self._stats_incrementMoteStats('rplTxDIO')
                
                
                
                
                
                # "send" DIO to all neighbors
                for neighbor in self._myNeigbors():
                    #print "Neighbor: "+str(neighbor.id)
                    # don't update DAGroot
                    if neighbor.dagRoot:
                        continue
                    
                    # don't update poor link
                    #emunicio
                    #with the 256 I force to use only high quality links. CAUTION! CAN CREATE LOOPS!!
                    #if neighbor._rpl_calcRankIncrease(self)>(self.RPL_MAX_RANK_INCREASE-350): 
                     ###!!!### if self.DEBUG: print "The rank increase with neigor "+str(neighbor.id)+" is "+str(neighbor._rpl_calcRankIncrease(self))+" and the MAX increase is "+str(self.RPL_MAX_RANK_INCREASE)+" and the PDR is "+str(self.getPDR(neighbor))
                    
                    if neighbor._rpl_calcRankIncrease(self)>(self.RPL_MAX_RANK_INCREASE):
                         ###!!!### if self.DEBUG: print str(neighbor.id)+" is a Low quality neighbor. His rank is: "+str(neighbor.rank)
                        continue
                     ###!!!### if self.DEBUG: print str(neighbor.id)+" is a possible candidate. His rank is: "+str(neighbor.rank)    
#                    if self.id==16:
#                        print "I am 16 Rank increase with "+str(neighbor.id)+" is "+str(neighbor._rpl_calcRankIncrease(self))+" MAX RANK INCREASE IS "+str(self.RPL_MAX_RANK_INCREASE)
                        
                        
                    # in neighbor, update my rank/DAGrank
                    neighbor.neighborDagRank[self]    = self.dagRank
                    neighbor.neighborRank[self]       = self.rank
                    
                    # in neighbor, update number of DIOs received
                    if self not in neighbor.rplRxDIO:
                        neighbor.rplRxDIO[self]       = 0
                    neighbor.rplRxDIO[self]          += 1
                    
                    # update my mote stats
                    self._stats_incrementMoteStats('rplRxDIO') # TODO: TX DIO?
                    
                    # skip useless housekeeping
                    if not neighbor.rank or self.rank<neighbor.rank:
                        # in neighbor, do RPL housekeeping
                        neighbor._rpl_housekeeping()                        
                    
                    # update time correction
                   
                    if neighbor.preferredParent == self:
                        #print "Updating time in "+str(neighbor.id)
                        
                        asn                        = self.engine.getAsn() 
#                        print "My ASN="+str(asn)
#                        print "His asn="+str(neighbor.timeCorrectedSlot)
                        neighbor.timeCorrectedSlot = asn
            
            # schedule to send the next DIO
            self._rpl_schedule_sendDIO()
    
    def _rpl_housekeeping(self):
        with self.dataLock:
            #print "Mote: "+str(self.id)+" my rank is: "+str(self.rank)
            #===
            # refresh the following parameters:
            # - self.preferredParent
            # - self.rank
            # - self.dagRank
            # - self.parentSet
#            print "Starting Housekeeping in mote "+str(self.id)
#            if self.preferredParent:
#                    print "I am "+str(self.id)+" My parent is "+str(self.preferredParent.id)+" my rank is "+str(self.rank)+" and the rank of my parent is "+str(self.preferredParent.rank)
            
            # calculate my potential rank with each of the motes I have heard a DIO from
            potentialRanks = {}
            for (neighbor,neighborRank) in self.neighborRank.items():
                # calculate the rank increase to that neighbor
                rankIncrease = self._rpl_calcRankIncrease(neighbor)
                 ###!!!### if self.DEBUG: print "Rank for mote "+str(neighbor.id)+" is: "+str(neighbor.rank)+" his increase is "+str(rankIncrease)
                 ###!!!### if self.DEBUG: print "This Rank Increase for mote "+str(neighbor.id)+" is: less or equal than the minimum between "+str(self.RPL_MAX_RANK_INCREASE)+" and "+str(self.RPL_MAX_TOTAL_RANK-neighborRank)
                if rankIncrease!=None and rankIncrease<=min([self.RPL_MAX_RANK_INCREASE, self.RPL_MAX_TOTAL_RANK-neighborRank]): 
                    #if self.DEBUG: print "This Rank Increase for mote "+str(neighbor.id)+" is: less or equal than "+str(self.RPL_MAX_RANK_INCREASE)+" or "+str(self.RPL_MAX_TOTAL_RANK-neighborRank):
                    ##to avoid loops, check that i am not the parent of my parent              
#                    if neighbor.preferredParent and neighbor.preferredParent.preferredParent==self:
#                        print "the parent of mote "+str(neighbor.id)+" is: "+str(neighbor.preferredParent)+" the parent of this one is "+str(neighbor.preferredParent.preferredParent)
#                        continue
                    # record this potential rank
                     # record this potential rank
                    if neighbor.preferredParent!=None:
                        if neighbor.preferredParent.id==self.id:
                             ###!!!### if self.DEBUG: print "Skipping this neighbor since I would create a loop"
                            continue
                        if neighbor.preferredParent.preferredParent!=None:
                            if neighbor.preferredParent.preferredParent.id==self.id:
                                 ###!!!### if self.DEBUG: print "Skipping this neighbor since I would create a loop"
                                continue
                            if neighbor.preferredParent.preferredParent.preferredParent!=None:
                                if neighbor.preferredParent.preferredParent.preferredParent.id==self.id:
                                     ###!!!### if self.DEBUG: print "Skipping this neighbor since I would create a loop"
                                    continue
                                if neighbor.preferredParent.preferredParent.preferredParent.preferredParent!=None:
                                    if neighbor.preferredParent.preferredParent.preferredParent.preferredParent.id==self.id:
                                         ###!!!### if self.DEBUG: print "Skipping this neighbor since I would create a loop"
                                        continue 
				    if neighbor.preferredParent.preferredParent.preferredParent.preferredParent.preferredParent!=None:
                                    	if neighbor.preferredParent.preferredParent.preferredParent.preferredParent.preferredParent.id==self.id:
                                             ###!!!### if self.DEBUG: print "Skipping this neighbor since I would create a loop"
                                            continue
					if neighbor.preferredParent.preferredParent.preferredParent.preferredParent.preferredParent.preferredParent!=None:
                                    	    if neighbor.preferredParent.preferredParent.preferredParent.preferredParent.preferredParent.preferredParent.id==self.id:
                                                 ###!!!### if self.DEBUG: print "Skipping this neighbor since I would create a loop"
                                        	continue                       
                    potentialRanks[neighbor] = neighborRank+rankIncrease
            
            # sort potential ranks
            #print "Potential ranks "+str(potentialRanks)
            sorted_potentialRanks = sorted(potentialRanks.iteritems(), key=lambda x:x[1])
            #print "Sorted Potential ranks "+str(sorted_potentialRanks)
            #print sorted_potentialRanks
            # switch parents only when rank difference is large enough
            for i in range(1,len(sorted_potentialRanks)):
                 ###!!!### if self.DEBUG: print str(i)+" "+str(sorted_potentialRanks[i][0].id)+" "+str(sorted_potentialRanks[i][1])
                if sorted_potentialRanks[i][0] in self.parentSet:
                    # compare the selected current parent with motes who have lower potential ranks 
                    # and who are not in the current parent set 
                    
                    for j in range(i):                    
                        if sorted_potentialRanks[j][0] not in self.parentSet:
                            if sorted_potentialRanks[i][1]-sorted_potentialRanks[j][1]<self.RPL_PARENT_SWITCH_THRESHOLD:
                                mote_rank = sorted_potentialRanks.pop(i)
                                sorted_potentialRanks.insert(j,mote_rank)
                                break
            
            
            
            # pick my preferred parent and resulting rank
            if sorted_potentialRanks:
                
#                for potential,prank in sorted_potentialRanks:
#                    print str(potential.id)+" has "+str(prank)
                
                oldParentSet = set([parent.id for parent in self.parentSet])
                #print oldParentSet
#                if self.preferredParent:
#                    print "I am "+str(self.id)+" and I could  change my current parent "+str(self.preferredParent.id)+" for one of these: "
#                    for p,r in sorted_potentialRanks:
#                        if p.id!=0: 
#                            print str(p.id)+" has rank "+str(r)+" and his parent is "+str(p.preferredParent.id)
#                            if p.preferredParent.id==self.id:   
#                                print "I would like to take this parent, but I will create a loop. I cant take "+str(p.id)
#                                print sorted_potentialRanks
#                                sorted_potentialRanks.remove((p,r))
#                                print sorted_potentialRanks
#                if self.preferredParent:                
#                    print "My actual parent is "+str(self.preferredParent.id)               
                (newPreferredParent,newrank) = sorted_potentialRanks[0]

                # compare a current preferred parent with new one
                if self.preferredParent and newPreferredParent!=self.preferredParent:
                    for (mote,rank) in sorted_potentialRanks[:self.RPL_PARENT_SET_SIZE]:
                        
                        if mote == self.preferredParent:                      
                            # switch preferred parent only when rank difference is large enough
                            if rank-newrank<self.RPL_PARENT_SWITCH_THRESHOLD:
                                (newPreferredParent,newrank) = (mote,rank)
                                #self.rplChanges+=1
                                
                            
                    # update mote stats
                    self._stats_incrementMoteStats('rplChurnPrefParent')
                    # log
                    self._log(
                        self.INFO,
                        "[rpl] churn: preferredParent {0}->{1}",
                        (self.preferredParent.id,newPreferredParent.id),
                    )
                
                # update mote stats
                if self.rank and newrank!=self.rank:
                    self._stats_incrementMoteStats('rplChurnRank')
                    # log
                    self._log(
                        self.INFO,
                        "[rpl] churn: rank {0}->{1}",
                        (self.rank,newrank),
                    )
#                if self.preferredParent:
#                    print "I am "+str(self.id)+" My parent was "+str(self.preferredParent.id) 
                # store new preferred parent and rank
                (self.preferredParent,self.rank) = (newPreferredParent,newrank)
                
        
#                if self.preferredParent.preferredParent:
#                    print "I am "+str(self.id)+" And now is parent "+str(self.preferredParent.id)+" the parent of my parent is "+str(self.preferredParent.preferredParent.id)
                
                #print "old DAG rank: "+str(self.dagRank)
                
                # calculate DAGrank
                self.dagRank = int(self.rank/self.RPL_MIN_HOP_RANK_INCREASE)
                #print "new DAG rank: "+str(self.dagRank)
                # pick my parent set
                self.parentSet = [n for (n,_) in sorted_potentialRanks if self.neighborRank[n]<self.rank][:self.RPL_PARENT_SET_SIZE]
                #print self.parentSet
                #print oldParentSet
                assert self.preferredParent in self.parentSet
                
#                    for (n,_) in sorted_potentialRanks:
#                        if self.neighborRank[n]<self.rank[:self.RPL_PARENT_SET_SIZE
                
                if oldParentSet!=set([parent.id for parent in self.parentSet]):
                    self._stats_incrementMoteStats('rplChurnParentSet')
      
                    #print "I am "+str(self.id)+" My new parent is"+str(newPreferredParent.id)
            #===
            # refresh the following parameters:
            # - self.trafficPortionPerParent
            
#            for p in self.parentSet:
#                print self.neighborRank[p]
#                print self._rpl_calcRankIncrease(p)
#                print str(self.neighborRank[p]+self._rpl_calcRankIncrease(p))
#                print str(1.0/(self.neighborRank[p]+self._rpl_calcRankIncrease(p)))
                
            
            etxs        = dict([(p, 1.0/(self.neighborRank[p]+self._rpl_calcRankIncrease(p))) for p in self.parentSet])
            sumEtxs     = float(sum(etxs.values()))
            
            
            
            self.trafficPortionPerParent = dict([(p, etxs[p]/sumEtxs) for p in self.parentSet])
            
            
            # remove TX cells to neighbor who are not in parent set
            for neighbor in self.numCellsToNeighbors.keys():
                if neighbor not in self.parentSet:
#                    if self.id==24: 
#                        #assert False
#                        print str(neighbor.id)+" is noy in my parent set: "+str(self.parentSet[0].id)
                    # log
                    self._log(
                        self.INFO,
                        "[otf] removing cell to {0}, since not in parentSet {1}",
                        (neighbor.id,[p.id for p in self.parentSet]),
                    )
                    
                    
#                    if self.numCellsToNeighbors[neighbor] != 0:
                    #assert False 
                    
                   
                    
                    
                    tsList=[(ts,ch) for (ts,ch), cell in self.schedule.iteritems() if cell['neighbor']==neighbor and cell['dir']==self.DIR_TX]
                    #print "Lista "+str(tsList)
                    if tsList:                     
                        #print "RPL. NEW Parent "+str(self.parentSet[0].id)+".  I'm "+str(self.id)+" and I'm going to delete the link between "+str(self.id)+" towards "+str(neighbor.id)+" my old parent was "+str(oldParentSet)
                        #print "RPL. NEW Parent "+str(self.parentSet[0].id)+".  I'm "+str(self.id)+" and I'm going to delete the link between "+str(self.id)+" towards "+str(neighbor.id)+" my old parent was "+str(self.parentSet[0].id)
                        cellsToNewParent=[(ts,ch) for (ts,ch), cell in self.schedule.iteritems() if cell['neighbor']==self.parentSet[0] and cell['dir']==self.DIR_TX]    
                        #if self.id==25: 
                            #print "RPL I'm "+str(self.id)+" and I'm going to delete "+str((cell['ts'],cell['ch']))+" towards "+str(neighbor.id)  
                            #print "I have cell with my new parent "+str(numCellsToNewParent)
                            #print "I have "+str(self.numCellsToNeighbors[neighbor])+" cells with "+str(neighbor.id)
                        
                        if len(cellsToNewParent)!=0:
                            #print "Now I CAN"
                            self._sixtop_cell_deletion_sender(neighbor,tsList)
                        #else:
                            #print "I can not yet"
    #                        print "Lista "+str(tsList)
    #                        assert False
                
#                else:
#                    if self.id==24: 
#                        print str(neighbor.id)+" is in my parent set. My parent is "+str(self.parentSet[0].id)
             ###!!!### if self.DEBUG: print "Exit Housekeeping in mote "+str(self.id)
                        
    def _rpl_calcRankIncrease(self, neighbor):
        
        with self.dataLock:
            
            
            
            # estimate the ETX to that neighbor
            etx = self._estimateETX(neighbor)
            
            #if etx:            
                #print "I am "+str(self.id)+" and my etx to neighbor "+str(neighbor.id)+" is ETX="+str(etx)+" and the rank increase is "+str(2*etx)     
            
            # return if that failed
            if not etx:
                return
            
            # per draft-ietf-6tisch-minimal, rank increase is 2*ETX*RPL_MIN_HOP_RANK_INCREASE
            return int(2*self.RPL_MIN_HOP_RANK_INCREASE*etx)
    
    #===== otf
    
    def _otf_schedule_housekeeping(self,firstOtf=False):
        

        if firstOtf:
	    #alfa=self.settings.slotframeLength*0.9*random.random()
            #delay= (self.otfHousekeepingPeriod*random.random()+alfa)

	    #alfa=self.otfHousekeepingPeriod*0.5*random.random()
	    alfa=0
            delay= (self.otfHousekeepingPeriod*(0.5+random.random())+alfa)
	    #min first at 2.5 sec, max last at 15.5

             ###!!!### print "I am "+str(self.id)+" Num hops to root "+str(self.hopsToRoot)+" Inicio OTF at "+str(delay)
        else:
            delay=self.otfHousekeepingPeriod*(0.9+0.2*random.random())
                  
        
        
        self.engine.scheduleIn(
            delay       = delay,
            cb          = self._otf_action_housekeeping,
            uniqueTag   = (self.id,'_otf_action_housekeeping'),
            priority    = 4,
        )
#	self.engine.scheduleIn(
#            delay       = self.otfHousekeepingPeriod*(0.9+0.2*random.random()),
#            cb          = self._otf_action_housekeeping,
#            uniqueTag   = (self.id,'_otf_action_housekeeping'),
#            priority    = 4,
#        )
        
    
    def _otf_action_housekeeping(self):
        '''
        OTF algorithm: decides when to add/delete cells.
        '''
        #print "Entering OTF house keeping"
        with self.dataLock:
        
            # calculate the "moving average" incoming traffic, in pkts since last cycle, per neighbor
            #print "OTF housekeeping "   
            # collect all neighbors I have RX cells to
            rxNeighbors = [cell['neighbor'] for ((ts,ch),cell) in self.schedule.items() if cell['dir']==self.DIR_RX]
            #print str(self.id)+" Schedule "+str(self.schedule.keys())
            #print str(self.id)+" Schedule "+str(self.schedule.items())
            
            
            # remove duplicates
            rxNeighbors = list(set(rxNeighbors))
            #print "Its me "+str(self.id)+" at "+str(self.engine.asn)+" I have "+str(len(rxNeighbors))+" RX neighbors"
            
            # reset inTrafficMovingAve                
            neighbors = self.inTrafficMovingAve.keys()
            for neighbor in neighbors:
                
                if neighbor not in rxNeighbors:
                    #print " Its me "+str(self.id)+" at "+str(self.engine.asn)+" "+str(neighbor.id)+" is not my RX neighbor"
                    del self.inTrafficMovingAve[neighbor]
            
            # set inTrafficMovingAve 
            for neighborOrMe in rxNeighbors+[self]:
                #print str(neighborOrMe)
                if neighborOrMe in self.inTrafficMovingAve:
                    #print " Its me "+str(self.id)+" at "+str(self.engine.asn)+" This is in trafficMovAve "+str(neighborOrMe.id)+" "
                    newTraffic   = 0
                    #print "new Traffic a "+str(newTraffic)+" "
                    newTraffic  += self.inTraffic[neighborOrMe]*self.OTF_TRAFFIC_SMOOTHING               # new
                    #print "new Traffic b "+str(newTraffic)+" "
                    newTraffic  += self.inTrafficMovingAve[neighborOrMe]*(1-self.OTF_TRAFFIC_SMOOTHING)  # old
                    #print "new Traffic c "+str(newTraffic)+" "
                    self.inTrafficMovingAve[neighborOrMe] = newTraffic
                elif self.inTraffic[neighborOrMe] != 0:
                    self.inTrafficMovingAve[neighborOrMe] = self.inTraffic[neighborOrMe]
                    #print "new Traffic d "+str(self.inTraffic[neighborOrMe])+" "
            
            # reset the incoming traffic statistics, so they can build up until next housekeeping
            self._otf_resetInboundTrafficCounters()
            
            # calculate my total generated traffic, in pkt/s
            genTraffic       = 0
            # generated/relayed by me
            for neighborOrMe in self.inTrafficMovingAve:
                genTraffic  += self.inTrafficMovingAve[neighborOrMe]/self.otfHousekeepingPeriod
              
            
            # convert to pkts/cycle
            genTraffic      *= self.settings.slotframeLength*self.settings.slotDuration
            
            
            
            remainingPortion = 0.0
            parent_portion   = self.trafficPortionPerParent.items()
            # sort list so that the parent assigned larger traffic can be checked first
            sorted_parent_portion = sorted(parent_portion, key = lambda x: x[1], reverse=True)
                     
#            print "Its me "+str(self.id)+" I have traffic "+str(genTraffic)+" to send neighbors. My parent are:"
#            for parent in self.parentSet:
#                print "Parent "+str(parent.id)
            
            # split genTraffic across parents, trigger 6top to add/delete cells accordingly
            for (parent,portion) in sorted_parent_portion:
                # if some portion is remaining, this is added to this parent
                if remainingPortion!=0.0:
                    portion                               += remainingPortion
                    remainingPortion                       = 0.0
                    self.trafficPortionPerParent[parent]   = portion
                    
                # calculate required number of cells to that parent
                etx = self._estimateETX(parent)
                
                                
                if etx>self.RPL_MAX_ETX: # cap ETX
                    etx  = self.RPL_MAX_ETX
                
                #reqCells      = int(math.ceil(portion*genTraffic*1))
                
                # calculate the OTF threshold
                threshold     = int(math.ceil(portion*self.settings.otfThreshold))
                
                # measure how many cells I have now to that parent
                nowCells      = self.numCellsToNeighbors.get(parent,0)
                if self.settings.otfEnabled==True:
                    reqCells      = int(math.ceil(portion*genTraffic*etx))  
		    #print "Portion "+str(portion)
		    #print "Traffic "+str(genTraffic)  
		    #print "ETX"+str(etx)
                else:
#                    if self.preferredParent != self.recordedParent or self.myFistOtfTime==True:    
#                        self.myFistOtfTime=False
                    self.myMaxCellDemand=self.getMyMaxCellDemand()
                    reqCells=self.myMaxCellDemand
                    
                    
                    
                        #use the optimal usage

                        
                 ###!!!### if self.DEBUG: print "I am "+str(self.id)+" and I require cells: "+str(len([(ts,c['ch'],c['neighbor']) for ((ts,ch),c) in self.schedule.items() if c['dir']==self.DIR_TX]))
                 ###!!!### if self.DEBUG: print "I should have cells: "+str(reqCells)
                 ###!!!### if self.DEBUG: print "I am "+str(self.id)+" nowCells: "+str(nowCells)
                self.numReqCells=reqCells
                #self.numCells=self.numDeniedCells+(numCells-len(givenCells))
    
                if nowCells==0 or nowCells<reqCells:
                    # I don't have enough cells
                    
                    # calculate how many to add
                    if reqCells>0:
                        # according to traffic
                        
                        numCellsToAdd = reqCells-nowCells+(threshold+1)/2
                    else:
                        # but at least one cell
                        
                        numCellsToAdd = 1
                    
                    #to avoid that some nodes get all schedule (max add 3 cells at a time)
                    #if self.settings.otfEnabled==False:  
                        #if numCellsToAdd>3:
                            #numCellsToAdd=3
                    #print "I am "+str(self.id)+" nowCells: "+str(nowCells)+" reqCells: "+str(reqCells)
                     ###!!!### if self.DEBUG: print "[otf] I'm {4} and not enough cells towards {0}: have {1}, need {2}, add {3}".format(parent.id,nowCells,reqCells,numCellsToAdd,self.id)
                    # log
                    self._log(
                        self.INFO,
                        "[otf] not enough cells to {0}: have {1}, need {2}, add {3}",
                        (parent.id,nowCells,reqCells,numCellsToAdd),
                    )
                    
                    # update mote stats
                    self._stats_incrementMoteStats('otfAdd')
                    
                    # have 6top add cells
                    self._sixtop_cell_reservation_request(parent,numCellsToAdd)
                    
                    # measure how many cells I have now to that parent
                    nowCells     = self.numCellsToNeighbors.get(parent,0)
                    
                    # store handled portion and remaining portion
                    if nowCells<reqCells:
                        if genTraffic > 0:    #to avoid float division by zero
                            handledPortion   = (float(nowCells)/etx)/genTraffic
                            remainingPortion = portion - handledPortion
                            self.trafficPortionPerParent[parent] = handledPortion
                    
                    # remember OTF triggered
                    otfTriggered = True
                
                elif reqCells<nowCells-threshold:
                    # I have too many cells
                    
                    # calculate how many to remove
                    #emunicio, I want always there is at least 1 cell available
                    numCellsToRemove = nowCells-reqCells
                    if reqCells==0:
                      numCellsToRemove=numCellsToRemove-1  
                     ###!!!### if self.DEBUG: print "[otf] too many cells to {0}:  have {1}, need {2}, remove {3}".format(parent.id,nowCells,reqCells,numCellsToRemove)
                    # log
                    self._log(
                        self.INFO,
                        "[otf] too many cells to {0}:  have {1}, need {2}, remove {3}",
                        (parent.id,nowCells,reqCells,numCellsToRemove),
                    )
                    
                    # update mote stats
                    self._stats_incrementMoteStats('otfRemove')
                    
                    # have 6top remove cells
                    self._sixtop_removeCells(parent,numCellsToRemove)
                    
                    # remember OTF triggered
                    otfTriggered = True
                    
                else:
                    # nothing to do
                     ###!!!### if self.DEBUG: print "[otf] {3}: OK cells to {0}:  have {1}, need {2}, add/remove 0".format(parent.id,nowCells,reqCells,self.id)
                    # remember OTF did NOT trigger
                    otfTriggered = False
                
                # maintain stats
                if otfTriggered:
                    now = self.engine.getAsn()
                    if not self.asnOTFevent:
                        assert not self.timeBetweenOTFevents
                    else:
                        self.timeBetweenOTFevents += [now-self.asnOTFevent]
                    self.asnOTFevent = now
            
            # schedule next housekeeping
            self._otf_schedule_housekeeping()

    def _otf_resetInboundTrafficCounters(self):
        with self.dataLock:
            for neighbor in self._myNeigbors()+[self]:
                #print "My neighbor is "+str(neighbor.id)
                self.inTraffic[neighbor] = 0
    
    def _otf_incrementIncomingTraffic(self,neighbor):
        with self.dataLock:
            self.inTraffic[neighbor] += 1
    
    #===== 6top
    
    def _sixtop_schedule_housekeeping(self):
        
        self.engine.scheduleIn(
            delay       = self.sixtopHousekeepingPeriod*(0.9+0.2*random.random()),
            cb          = self._sixtop_action_housekeeping,
            uniqueTag   = (self.id,'_sixtop_action_housekeeping'),
            priority    = 5,
        )
    
    def _sixtop_action_housekeeping(self):
        '''
        For each neighbor I have TX cells to, relocate cells if needed.
        '''
        
        #=== tx-triggered housekeeping 
        
        # collect all neighbors I have TX cells to
        txNeighbors = [cell['neighbor'] for ((ts,ch),cell) in self.schedule.items() if cell['dir']==self.DIR_TX]
        
        # remove duplicates
        txNeighbors = list(set(txNeighbors))
        
        #print "Its me "+str(self.id)+" I have these cells, "+str(len(self.schedule.keys()))+" : "+str(self.schedule.keys())+" My TX neigbhors are "+str(len(txNeighbors))

              
        
#        for neighbor in txNeighbors:
#            print neighbor.id
         ###!!!### if self.DEBUG: print "Its me "+str(self.id)+" I have "+str(len(txNeighbors))+" TX neighbors"
        for neighbor in txNeighbors:
            nowCells = self.numCellsToNeighbors.get(neighbor,0)
            
#            cells = len([t for ((t,ch),c) in self.schedule.items() if c['dir']==self.DIR_TX and c['neighbor']==neighbor])
#            
#            for ((t,ch),c) in self.schedule.items():
#                if c['neighbor']==neighbor:
#                    print "This neigbor is using the cell "+str((t,ch))
#                    
#                    
#            if self.DEBUG: print "With Neighbor : "+str(neighbor.id)+" I have "+str(nowCells)
#            if self.DEBUG: print "With Neighbor : "+str(neighbor.id)+" I have "+str(cells)
            #for (t,c) in self.schedule.items():
            #    print "Check cell is for "+str(c['neighbor'].id)+" con direccion "+str(c['dir'])
            #    if c['dir']==self.DIR_TX and c['neighbor']==neighbor:
                    #print "This cell is for "+str(neighbor.id)+" con direccion "+str(c['dir']) 
            #        print "Ok"
            #print "OJO nowCells: "+str(len([t for (t,c) in self.schedule.items() if c['dir']==self.DIR_TX and c['neighbor']==neighbor]))
            
            
            #for neighbor in txNeighbors:
            #print neighbor.id
            #for ((t,ch),c) in self.schedule.items():
                ##print "Cell "+str(t)+" ,"+str(ch)+" has the neighbor "+str(c['neighbor'].id)
                #if c['dir']==self.DIR_TX and c['neighbor']==neighbor:
                    #print "With "+str(neighbor.id)+" I have the Cell "+str(t)+" ,"+str(ch)
            
            
            
            #cells = len([t for ((t,ch),c) in self.schedule.items() if c['dir']==self.DIR_TX and c['neighbor']==neighbor])
            #print "nowCells is "+str(nowCells)+" but cells to this neighbor are "+str(cells)
            assert nowCells == len([t for ((t,ch),c) in self.schedule.items() if c['dir']==self.DIR_TX and c['neighbor']==neighbor])
         #no housekeeping
        # do some housekeeping for each neighbor
        for neighbor in txNeighbors:
            self._sixtop_txhousekeeping_per_neighbor(neighbor)
        
        #=== rx-triggered housekeeping 
        
        # collect neighbors from which I have RX cells that is detected as collision cell
        rxNeighbors = [cell['neighbor'] for ((ts,ch),cell) in self.schedule.items() if cell['dir']==self.DIR_RX and cell['rxDetectedCollision']]
        #rxNeighbors2 = [cell['neighbor'] for ((ts,ch),cell) in self.schedule.items() if cell['dir']==self.DIR_RX]
        
        # remove duplicates
        rxNeighbors = list(set(rxNeighbors))
        #rxNeighbors2 = list(set(rxNeighbors2))
         ###!!!### if len(rxNeighbors)!=0:
             ###!!!### if self.DEBUGCLEAN: print "Its me "+str(self.id)+" I have these cells, "+str(len(self.schedule.keys()))+" : "+str(self.schedule.keys())+" I have collisions with the neighbors "+str(len(rxNeighbors))   
        
        for neighbor in rxNeighbors:
            nowCells = self.numCellsFromNeighbors.get(neighbor,0)
            assert nowCells == len([t for ((t,ch),c) in self.schedule.items() if c['dir']==self.DIR_RX and c['neighbor']==neighbor])
            
        #no housekeeping
        # do some housekeeping for each neighbor
        for neighbor in rxNeighbors:
            self._sixtop_rxhousekeeping_per_neighbor(neighbor)
        
        
        #=== neighbor-schedule-triggered housekeeping        
        
#        if self.ApplyChanges:
#            for neigh in self.scheduleNeigborhood.keys():
#                #print "Its me "+str(self.id)+" I have as neighbor "+str(neigh.id)+" an he has "+str(self.scheduleNeigborhood[neigh])
#                for (ts,ch) in self.schedule.keys():            
#                    if (ts,ch) in self.scheduleNeigborhood[neigh] and (ts,ch) != (0,0):
#                        cell=self.schedule.get((ts,ch))
#                        if cell['dir']==self.DIR_TX:
#                            if self.DEBUG: print "RELOCATION MUST BE DONE: "+str((ts,ch))+" between "+str(self.id)+" and "+str(neigh.id)
#                            #print "Its me "+str(self.id)+" I have the cell "+str((ts,ch))+" as TX with "+str(self.schedule.get((ts,ch))['neighbor'].id)
#                            self._sixtop_cell_reservation_request(cell['neighbor'],1)
#                            self._sixtop_cell_deletion_sender(cell['neighbor'],[(ts,ch)])
        
#        #try to obtain optimal
#        relocationPerformed=0
#        #print "Its me "+str(self.id)+"my schedule is "+str(self.schedule.keys()) 
#        for cellkey in self.schedule.keys():
#            if cellkey != (0,0):
#                cell=self.schedule[cellkey]
#                #print str(cellkey)+" - "+str(cell['neighbor'].id)
#                for neigh in self.engine.motes:
#                    if neigh.id != self.id and neigh != cell['neighbor']:
#                         if cellkey in neigh.schedule.keys():
#                            neighborcell=neigh.schedule[cellkey]
#                            #print "I am "+str(neigh.id)+" and I have this same cell "+str(cellkey)+" - "+str(neighborcell['neighbor'].id)
#                            if cell['dir']==self.DIR_TX and neighborcell['dir']==self.DIR_TX:
#                                if self.getRSSI(neigh) > neigh.minRssi and neigh.getRSSI(self) > self.minRssi: 
#                                    #print "Its me "+str(self.id)+" I can see neighbor "+str(neigh.id)+" an he has "+str(neigh.schedule.keys()) 
#                                    #print "Its me "+str(self.id)+" I have this TX cell "+ str(cellkey)+" -> "+str(cell['neighbor'].id)
#                                    #print "Its me "+str(neigh.id)+" I also have this TX cell "+str(cellkey)+" -> "+str(neighborcell['neighbor'].id)
#                                    
#                                    print "I AM "+str(self.id)+"RELOCATION MUST BE DONE: "+str((cellkey[0],cellkey[1]))+" between "+str(self.id)+" and "+str(cell['neighbor'].id)
##                                   secondpause=self.engine.asn+1  
##                                   self.engine.pauseAtAsn(secondpause)
##                                   print cell
##                                   print "Its me "+str(self.id)+" I have the cell "+str((cellkey[0],cellkey[1]))+" as TX with "+str(cell['neighbor'].id)
##                                   print "this cell is also in "+str(neigh.id)
#                                    self._sixtop_cell_reservation_request(cell['neighbor'],1)
#                                    self._sixtop_cell_deletion_sender(cell['neighbor'],[(cellkey[0],cellkey[1])])
#                                    relocationPerformed=1
#                                    break
#                if relocationPerformed==0:
#                    break
#                else:
#                    print "Looking for more duplicated cells in my schedule"                       
                                   
                        
           
#           for neigh in self.engine.motes:
#                    if self.getRSSI(neigh) > neigh.minRssi and neigh.getRSSI(self) > self.minRssi:
#                        for cell in neigh.schedule.keys():
#                            if cell != (0,0):
#                                if [cell[0],cell[1]] in availableCells:
#                                    availableCells.remove([cell[0],cell[1]])


             
                        
                    #assert False
#                        for m in self.engine.motes:
#                            myneigh=cell['neighbor']
#                            if m.id==myneigh.id:
#                                self._sixtop_cell_reservation_request(m,1)
#                       
#                                self._sixtop_cell_deletion_sender(m,[(ts,ch)])
#                                #print "The mote is my EMS "+str(m.id)+"and its schedule is:"+str(m.schedule.keys())
#                        
#                        #print "This cell is with "+str(self.schedule.get((ts,ch))['neighbor'].id)
#                        
#                                print "RELOCATION"
#                        
                        
                    
            
        
        #=== schedule next housekeeping
        
        self._sixtop_schedule_housekeeping()
    
    def _sixtop_txhousekeeping_per_neighbor(self,neighbor):
        '''
        For a particular neighbor, decide to relocate cells if needed.
        '''
        #print "Relocate TX cell!"
        #===== step 1. collect statistics
        
        #print "I'm "+str(self.id)+" my neighbor is "+str(neighbor.id)+"Check relocation:"
        
        
        # pdr for each cell
        cell_pdr = []
        for ((ts,ch),cell) in self.schedule.items():
            if cell['neighbor']==neighbor and cell['dir']==self.DIR_TX:
                # this is a TX cell to that neighbor
                #print "Check relocating: I'm "+str(self.id)+" my neighbor "+str(neighbor.id)+" values are: ts "+str(ts)+" ch "+str(ch)
                # abort if not enough TX to calculate meaningful PDR
                if cell['numTx']<self.NUM_SUFFICIENT_TX:
                    continue
                
                # calculate pdr for that cell
                recentHistory = cell['history'][-self.NUM_MAX_HISTORY:]
                pdr = float(sum(recentHistory)) / float(len(recentHistory))
                
                # store result
                cell_pdr += [((ts,ch),pdr)]
        #print "Check relocating: I'm "+str(self.id)+" my neighbor is "+str(neighbor.id)+" and cell_pdr are "+str(cell_pdr) 
        
        
        # pdr for the bundle as a whole
        bundleNumTx     = sum([len(cell['history'][-self.NUM_MAX_HISTORY:]) for cell in self.schedule.values() if cell['neighbor']==neighbor and cell['dir']==self.DIR_TX])
        bundleNumTxAck  = sum([sum(cell['history'][-self.NUM_MAX_HISTORY:]) for cell in self.schedule.values() if cell['neighbor']==neighbor and cell['dir']==self.DIR_TX])
        if bundleNumTx<self.NUM_SUFFICIENT_TX:
            bundlePdr   = None
        else:
            bundlePdr   = float(bundleNumTxAck) / float(bundleNumTx)
        
        #===== step 2. relocate worst cell in bundle, if any
        # this step will identify the cell with the lowest PDR in the bundle.
        # If its PDR is self.sixtopPdrThreshold lower than the average of the bundle
        # this step will move that cell.
        
        relocation = False
        
        if cell_pdr:
            
            # identify the cell with worst pdr, and calculate the average
            
            worst_tsch   = None
            worst_pdr  = None
            
            for ((ts,ch),pdr) in cell_pdr:
                if worst_pdr==None or pdr<worst_pdr:
                    worst_tsch  = (ts,ch)
                    worst_pdr = pdr
            
            assert worst_tsch!=None
            assert worst_pdr!=None
            
            # ave pdr for other cells
            othersNumTx      = sum([len(cell['history'][-self.NUM_MAX_HISTORY:]) for ((ts,ch),cell) in self.schedule.items() if cell['neighbor']==neighbor and cell['dir']==self.DIR_TX and ts != worst_tsch])
            othersNumTxAck   = sum([sum(cell['history'][-self.NUM_MAX_HISTORY:]) for ((ts,ch),cell) in self.schedule.items() if cell['neighbor']==neighbor and cell['dir']==self.DIR_TX and ts != worst_tsch])           
            if othersNumTx<self.NUM_SUFFICIENT_TX:
                ave_pdr      = None
            else:
                ave_pdr      = float(othersNumTxAck) / float(othersNumTx)

            # relocate worst cell if "bad enough"
            if ave_pdr and worst_pdr<(ave_pdr/self.sixtopPdrThreshold):
                
                # log
                self._log(
                    self.INFO,
                    "[6top] relocating cell ts {0} to {1} (pdr={2:.3f} significantly worse than others {3})",
                    (worst_tsch,neighbor.id,worst_pdr,cell_pdr),
                )
                 ###!!!### if self.DEBUG: print "[6top] {4} relocating cell ts {0} to {1} (pdr={2:.3f} significantly worse than others {3})".format(worst_tsch,neighbor.id,worst_pdr,cell_pdr,self.id)
                # measure how many cells I have now to that parent
                nowCells = self.numCellsToNeighbors.get(neighbor,0)
                #print "RELOCATING 1"
                # relocate: add new first
                if self._sixtop_cell_reservation_request(neighbor,1) == 1:
                   
                
                    # relocate: remove old only when successfully added 
                    if nowCells < self.numCellsToNeighbors.get(neighbor,0):
    #                    if self.id==38:
                        #print "HK per Neighbor: I'm the Parent and I'm going to relocate towards "+str(neighbor.id)
    #                        print "PArent"+str(self.id)+" has cells "+str(len(self.getTxCells()))
    #                        print "mote neigbor "+str(neighbor.id)+" has cells "+str(len(self.getTxCells()))
                        if len(self.getTxCells())!=0:
                            self._sixtop_cell_deletion_sender(neighbor,[worst_tsch])
                    
                            # update stats
                            self._stats_incrementMoteStats('topTxRelocatedCells')
                            #print "Relocation 1 OK"
                            # remember I relocated a cell for that bundle
                            relocation = True
                
                    #assert False
        
        #===== step 3. relocate the complete bundle
        # this step only runs if the previous hasn't, and we were able to
        # calculate a bundle PDR.
        # This step verifies that the average PDR for the complete bundle is
        # expected, given the RSSI to that neighbor. If it's lower, this step
        # will move all cells in the bundle.
        
        bundleRelocation = False
        
        if (not relocation) and bundlePdr!=None:
            
            # calculate the theoretical PDR to that neighbor, using the measured RSSI
            rssi            = self.getRSSI(neighbor)
            theoPDR         = Topology.Topology.rssiToPdr(rssi)
            
            # relocate complete bundle if measured RSSI is significantly worse than theoretical
            if bundlePdr<(theoPDR/self.sixtopPdrThreshold):
                 ###!!!### if self.DEBUG: print "RELOCATING 2: I'm "+str(self.id)+" my neighbor "+str(neighbor.id)+" has bundle "+str(bundlePdr)+" and thPDR/threshold "+str(theoPDR/self.sixtopPdrThreshold)
                 ###!!!### if self.DEBUG: print "RELOCATING 2: I'm "+str(self.id)+" my neighbor "+str(neighbor.id)+" and cell_pdr are "+str(cell_pdr)
                for ((ts,ch),_) in cell_pdr:
                    
                    # log
                    self._log(
                        self.INFO,
                        "[6top] relocating cell ts {0} to {1} (bundle pdr {2} << theoretical pdr {3})",
                        (ts,neighbor,bundlePdr,theoPDR),
                    )
                     ###!!!### if self.DEBUG: print "[6top] relocating cell ts {0} to {1} (bundle pdr {2} << theoretical pdr {3})".format(ts,neighbor.id,bundlePdr,theoPDR)
                    # measure how many cells I have now to that parent
                    nowCells = self.numCellsToNeighbors.get(neighbor,0)
                    #print "RELOCATING 2: I'm "+str(self.id)+" my nowCells to neighbor "+str(neighbor.id)+" are "+str(nowCells)
                     ###!!!### if self.DEBUG: print "This cell is "+str((ts,ch))
                    # relocate: add new first
                    if self._sixtop_cell_reservation_request(neighbor,1) == 1:

                        # relocate: remove old only when successfully added 
                        if nowCells < self.numCellsToNeighbors.get(neighbor,0):
                            if len(self.getTxCells())!=0:
                                self._sixtop_cell_deletion_sender(neighbor,[(ts,ch)])
                                #print "Relocation 2 OK"
                                bundleRelocation = True
                        
                # update stats
                if bundleRelocation:
                    self._stats_incrementMoteStats('topTxRelocatedBundles')
                 ###!!!### else:
                     ###!!!### if self.DEBUG: print "Relocation 2 ERROR"
                    #assert False
    
    def _sixtop_rxhousekeeping_per_neighbor(self,neighbor):
        '''
        The RX node triggers a relocation when it has heard a packet
        from a neighbor it did not expect ('rxDetectedCollision')
        '''
         ###!!!### if self.DEBUG: print "Relocate RX cell, collision!"        
        
        rxCells = [((ts,ch),cell) for ((ts,ch),cell) in self.schedule.items() if cell['dir']==self.DIR_RX and cell['rxDetectedCollision'] and cell['neighbor']==neighbor]
        
#        print "I'm "+str(self.id)
#        for ((ts,ch),cell) in self.schedule.items():
#            if cell['dir']==self.DIR_RX:
#                if cell['rxDetectedCollision']==True:
#                    if cell['neighbor']==neighbor:
#                        print cell
        
        relocation = False
        for (ts,ch),cell in rxCells:
            
            # measure how many cells I have now from that child
            nowCells = self.numCellsFromNeighbors.get(neighbor,0)
            #print "THERE IS A COLLISION from "+str(self.id)+" -> to "+str(neighbor.id)+" Cell "+str((ts,ch))
#            print "I'm "+str(self.id)+" I have a collision with my "+str(neighbor.id)+" in the cell "+str((ts,ch))+" Relocating...First add new cell"
#            print "My schedule "+str(self.schedule.keys())
#            print "His schedule "+str(neighbor.schedule.keys())
            #only for the broadcast module
            
#            if self.scheduleNeigborhood.has_key((ts,ch)):
#                if self.DEBUG: print "In my neighborhood seems to be used"
#                assert False
#            else:
#                print "In my neighborhood seems to be free"
            
            # relocate: add new first
            #bug! before remove, it is necessary to check if a new cell has been really reserved, this happens in all calls to _sixtop_cell_deletion_sender 
            # fiexd cheking the return value of _sixtop_cell_reservation_request
            
            
            if self._sixtop_cell_reservation_request(neighbor,1,dir=self.DIR_RX) == 1:
            
                # relocate: remove old only when successfully added 
                if nowCells < self.numCellsFromNeighbors.get(neighbor,0):
                    #print "SENDER2 "+str(self.getTxCells())
                    if self.getTxCells():
                    #if self.id==38:
#                        print "PArent "+str(self.id)+" has cells "+str(self.getRxCells())
#                        print "Children "+str(neighbor.id)+" has cells "+str(self.getTxCells())
                        neighbor._sixtop_cell_deletion_sender(self,[(ts,ch)])
                        #print "Relocation RX ok"
                        # remember I relocated a cell
                        relocation = True

        if relocation:
            # update stats
             ###!!!### if self.DEBUG: print "Relocation 3 ok between "+str((self.id,neighbor.id))
            self._stats_incrementMoteStats('topRxRelocatedCells')
         ###!!!### else:
             ###!!!### if self.DEBUG: print "Relocation 3 ERROR"
            #assert False
    
    def _sixtop_cell_reservation_request(self,neighbor,numCells,dir=DIR_TX):
        ''' tries to reserve numCells cells to a neighbor. '''
        
        with self.dataLock:
            
            #request numCells to my parent
            
            
#            while True:
#                cellsNotRepeatedByMe=True
#                givenCells       = neighbor._sixtop_cell_reservation_response2(self,numCells,dir)
#                print "I'm mote "+str(self.id)+". The cells "+str(givenCells)+ " have been selected as candidates in my neighbor "+str(neighbor.id)
#                for i in givenCells:
#                    cell=givenCells[i]
#                    print cell
#                    if self.schedule.has_key((cell[0],cell[1])):
#                        print "Error, this cell is already used by me: "+str(cell)
#                        cellsNotRepeatedByMe=False
#                    else:
#                        print "This cell is also ok for me: "+str(cell)
#                if cellsNotRepeatedByMe:
#                     break
            givenCells={}
            givenCells_firstRound={}
            givenCells_secondRound={} 
             ###!!!### if self.DEBUG: print "Im going to reserve cells: "+str(numCells) 
             ###!!!### if self.DEBUG: print "from : "+str(self.id)
             ###!!!### if self.DEBUG: print "to : "+str(neighbor.id) 
             ###!!!### if self.DEBUG: print "with dir: "+str(dir)
            if self.engine.scheduler=='none':
                #print "Using none"
                givenCells       = neighbor._sixtop_cell_reservation_response_random(self,numCells,dir)
            elif self.engine.scheduler=='cen':
                #print "Using cen"
                givenCells       = neighbor._sixtop_cell_reservation_response_centralized_noOverlapping(self,numCells,dir)
            elif self.engine.scheduler=='opt1':
                #print "Using opt"
                givenCells       = neighbor._sixtop_cell_reservation_response_centralized_optimized(self,numCells,dir)
            elif self.engine.scheduler=='opt2':
                #print "Using opt2"
                givenCells_firstRound       = neighbor._sixtop_cell_reservation_response_centralized_optimized(self,numCells,dir)
                if len(givenCells_firstRound)<numCells:
                    givenCells_secondRound = neighbor._sixtop_cell_reservation_response_random(self,numCells-len(givenCells_firstRound),dir)           
            elif self.engine.scheduler=='broad':
                #print "Using broad"
                #givenCells       = neighbor._sixtop_cell_reservation_response_withBroadcasts(self,numCells,dir)
                givenCells_firstRound       = neighbor._sixtop_cell_reservation_response_withBroadcasts(self,numCells,dir)
                if len(givenCells_firstRound)<numCells:
                    givenCells_secondRound = neighbor._sixtop_cell_reservation_response_random(self,numCells-len(givenCells_firstRound),dir)
            else:
                print "Unknown scheduler"
                assert False
                
             ###!!!### if self.DEBUG: print "I'm mote "+str(self.id)+". The cells "+str(givenCells_firstRound)+ " have been selected as candidates in my neighbor "+str(neighbor.id)+" in the first round"
            
             ###!!!### if self.DEBUG: print "I'm mote "+str(self.id)+". The cells "+str(givenCells_secondRound)+ " have been selected as candidates in my neighbor "+str(neighbor.id)+" in the second round" 
            
            
            
            i=0
            while i < len(givenCells_firstRound):
                givenCells[i]=givenCells_firstRound[i]
                i+=1
            j=i
            i=0
            while i < len(givenCells_secondRound):
                givenCells[i+j]=givenCells_secondRound[i]
                i+=1
                                    
            ###!!!### if self.DEBUG: print "I'm mote "+str(self.id)+". The  total cells "+str(givenCells)+ " have been selected as candidates in my neighbor "+str(neighbor.id)
           
            if len(givenCells) != numCells:
                
                #print "I am "+str(self.id)+" I am "+str(numCells-len(givenCells))+" less"
                
                for i in range(numCells-len(givenCells)):
                	###!!!### if self.DEBUG: print "I have received less cells than I asked for "+str((len(givenCells), numCells))
                    	self._stats_incrementMoteStats('cellsNotGiven')
                #assert False
                #self.cellsNotGiven+=1

            cellList    = []
            for i,val in givenCells.iteritems():
                self._log(
                    self.INFO,
                    '[6top] add RX cell ts={0},ch={1} from {2} to {3}',
                    (val[0],val[1],self.id,neighbor.id),
                )
                cellList         += [(val[0],val[1],dir)]
                ###!!!### if self.DEBUG: print "I am {4} add TX cell ts={0},ch={1} from {2} to {3}".format(val[0],val[1],self.id,neighbor.id, self.id)              
#            if len(cellList) !=numCells:
#                print "NOT enough cells!"
                #assert False
            self._tsch_addCells(neighbor,cellList)
            ###!!!### if self.DEBUG: print "I am "+str(self.id)+" my schedule after adding is "+str(self.schedule.keys())
            ###!!!### if self.DEBUG: print "and my neighbor "+str(neighbor.id)+" my schedule after adding is "+str(neighbor.schedule.keys())  
            ###!!!### if self.DEBUG: print "After add :"+str(cellList)
           ###!!!###  if self.DEBUG: print "We are sharing the cells:"+str(list(set(self.schedule.keys()).intersection(neighbor.schedule.keys())))
            
            # update counters
            if dir==self.DIR_TX:
                if neighbor not in self.numCellsToNeighbors:
                    self.numCellsToNeighbors[neighbor]     = 0
                self.numCellsToNeighbors[neighbor]        += len(givenCells)
            else:
                if neighbor not in self.numCellsFromNeighbors:
                    self.numCellsFromNeighbors[neighbor]   = 0
                self.numCellsFromNeighbors[neighbor]      += len(givenCells)
                
            if len(givenCells)!=numCells:
                # log
                self._log(
                    self.ERROR,
                    '[6top] scheduled {0} cells out of {1} required between motes {2} and {3}',
                    (len(givenCells),numCells,self.id,neighbor.id),
                )
                #print "NO ALL CELLS WERE AVAILABE"
                #assert False
            return len(givenCells)
   
            

    def _sixtop_cell_reservation_response_random(self,neighbor,numCells,dirNeighbor):
        ''' get a response from the neighbor. '''
         
        with self.dataLock:
           
            #in the parent, numCells are tried to be reserved
            

	    self.numRandomSelections+=1

            # set direction of cells
            if dirNeighbor == self.DIR_TX:
                dir = self.DIR_RX
            else:
                dir = self.DIR_TX
                                    
            ###!!!### if self.DEBUG: print "I am "+str(self.id)+" I have received a request from"+str(neighbor.id)+" my schedule is "+str(self.schedule.keys())+" and he wants cells: "+str(numCells)
            
            #this are all my cells
            allCells = []
            for x in range(0,self.settings.slotframeLength):
                for y in range(0,self.settings.numChans):
                #if x==0:
                    cell=['0','0']
                    cell[0]=x
                    cell[1]=y
                    allCells.append(cell)
            ###!!!### if self.DEBUG: print " all  cells: "+str(len(allCells))
            ###!!!### if self.DEBUG: print "all cells: "+str(allCells)
            #these are all my available cells
                    
            
            
            availableCells = []
            #print "Avalialbe cells: "+str(len(availableCells))
            for cell in allCells: 
                if not (cell[0],cell[1]) in self.schedule:
                    if not (cell[0],cell[1]) in neighbor.schedule:
                        availableCells.append(cell) 
                        #print "cell is available: "+str((cell[0],cell[1]))
                        #availableCells.remove([cell[0],cell[1]])
            #print "After check my schedule Avalialbe cells: "+str(len(availableCells)) 
            #print "After check my schedule Avalialbe cells: "+str(availableCells)
                        
             
            #self.numcellsLearned=len(availableCells)
            
            #print "all  cells: "+str(len(allCells))
            #print "Avalialbe cells: "+str(availableCells)       
            #print "Avoidable cells: "+str(avoidableCells)  
            #initcell=[0,0]
            #availableCells.remove(initcell)
           
            #print "all cells: "+str(len(allCells))
            ###!!!### if self.DEBUG: print "Avalialbe cells: "+str(len(availableCells))
             
            #if I have cells, I try to assign them
            selectedCells={}
            if len(availableCells) > 0:
                random.shuffle(availableCells)
                
#                if len(availableCells) < numCells:
#                    print "Not as much as I wanted"    
               
                #if they request more cells than I have, I try to give them the maxium available
                while len(availableCells) < numCells:
                    numCells=numCells-1 
                
                ranChosen=random.sample(range(0, len(availableCells)), numCells)
                
                #these are my selected cells
                for i in range(numCells):
                    selectedCells[i]=availableCells[ranChosen[i]]
         
                ###!!!### if self.DEBUG: print "I am "+str(self.id)+" and I have RANDOMLY selected cells: "+str(selectedCells)
                
                cellList              = []
                
                for i,val in selectedCells.iteritems():
                    # log
                    self._log(
                        self.INFO,
                        '[6top] add RX cell ts={0},ch={1} from {2} to {3}',
                        (val[0],val[1],self.id,neighbor.id),
                    )
                    cellList         += [(val[0],val[1],dir)]
                self._tsch_addCells(neighbor,cellList)            
                                    
                # update counters
                if dir==self.DIR_TX:
                    if neighbor not in self.numCellsToNeighbors:
                        self.numCellsToNeighbors[neighbor]     = 0
                    self.numCellsToNeighbors[neighbor]        += len(selectedCells)
                else:
                    if neighbor not in self.numCellsFromNeighbors:
                        self.numCellsFromNeighbors[neighbor]   = 0
                    self.numCellsFromNeighbors[neighbor]      += len(selectedCells)
            
            
            #print "So since I am "+str(self.id)+" all my cells are "+str(self.schedule.keys())+" and I have for my neighbor "+str(neighbor.id)+" cells: "+str(self.numCellsFromNeighbors[neighbor])
            
            return selectedCells



    def _sixtop_cell_reservation_response_withBroadcasts(self,neighbor,numCells,dirNeighbor):
        ''' get a response from the neighbor. '''
         
        with self.dataLock:
           
            #in the parent, numCells are tried to be reserved
           
            # set direction of cells
            if dirNeighbor == self.DIR_TX:
                dir = self.DIR_RX
            else:
                dir = self.DIR_TX
                                    
            ###!!!### if self.DEBUG: print "I am "+str(self.id)+" I have received a request from"+str(neighbor.id)+" my schedule is "+str(self.schedule.keys())+" and he wants cells: "+str(numCells)
            
            #this are all my cells
            allCells = []
            for x in range(0,self.settings.slotframeLength):
                for y in range(0,self.settings.numChans):
                    cell=['0','0']
                    cell[0]=x
                    cell[1]=y
                    allCells.append(cell)
            ###!!!### if self.DEBUG: print " all  cells: "+str(len(allCells))         
            #these are all my available cells
                    
            
            
            availableCells = []
            for cell in allCells: 
                if not (cell[0],cell[1]) in self.schedule:
                    if not (cell[0],cell[1]) in neighbor.schedule:
                        availableCells.append(cell) 
                        #print "cell is available: "+str((cell[0],cell[1]))
                        #availableCells.remove([cell[0],cell[1]])
            ###!!!### if self.DEBUG: print "After check my schedule Avalialbe cells: "+str(len(availableCells)) 
            ###!!!### if self.DEBUG: print "After check my schedule Avalialbe cells: "+str(availableCells)
                                       
            #check if has improved with broadcast
            for neigh in self.scheduleNeigborhood.keys():
                for cell in self.scheduleNeigborhood[neigh]:
                    if cell[0]!=0:
                        ###!!!### if self.DEBUG: print "Cells I have to avoid: Neighbor"+str(neigh.id)+ " cell "+str((cell[0],cell[1]))
                        #print "Avalialbe cells: "+str(availableCells)
                        ###!!!### if self.DEBUG: print "cell: "+str(cell) 
                        if [cell[0],cell[1]] in availableCells:
                            ###!!!### if self.DEBUG: print "This cell I could have used, but im not going to use it "+str(cell)
                            availableCells.remove([cell[0],cell[1]])
                    
            ###!!!### if self.DEBUG: print "Avalialbe cells after check mith all nodes: "+str(len(availableCells))  
            #self.numcellsLearned=len(availableCells)
            ###!!!### if self.DEBUG: print "After check all schedules Avalialbe cells: "+str(availableCells) 
            #print "all  cells: "+str(len(allCells))
            #print "Avalialbe cells: "+str(availableCells)       
            #print "Avoidable cells: "+str(avoidableCells)  
            #initcell=[0,0]
            #availableCells.remove(initcell)
           
            ###!!!### if self.DEBUG: print "all  cells: "+str(len(allCells))
            ###!!!### if self.DEBUG: print "Avalialbe cells: "+str(len(availableCells))
             
            #if I have cells, I try to assign them
            selectedCells={}
            if len(availableCells) > 0:
                random.shuffle(availableCells)
                
               
                #if they request more cells than I have, I try to give them the maxium available
                while len(availableCells) < numCells:
                    numCells=numCells-1 
                
                ranChosen=random.sample(range(0, len(availableCells)), numCells)
                
                #these are my selected cells
                for i in range(numCells):
                    selectedCells[i]=availableCells[ranChosen[i]]
         
                ###!!!### if self.DEBUG: print "I am "+str(self.id)+" and I have selected selected cells are "+str(selectedCells)
                
                cellList              = []
                
                for i,val in selectedCells.iteritems():
                    # log
                    self._log(
                        self.INFO,
                        '[6top] add RX cell ts={0},ch={1} from {2} to {3}',
                        (val[0],val[1],self.id,neighbor.id),
                    )
                    cellList         += [(val[0],val[1],dir)]
                self._tsch_addCells(neighbor,cellList)            
                                    
                # update counters
                if dir==self.DIR_TX:
                    if neighbor not in self.numCellsToNeighbors:
                        self.numCellsToNeighbors[neighbor]     = 0
                    self.numCellsToNeighbors[neighbor]        += len(selectedCells)
                else:
                    if neighbor not in self.numCellsFromNeighbors:
                        self.numCellsFromNeighbors[neighbor]   = 0
                    self.numCellsFromNeighbors[neighbor]      += len(selectedCells)
            
            
            #print "So since I am "+str(self.id)+" all my cells are "+str(self.schedule.keys())+" and I have for my neighbor "+str(neighbor.id)+" cells: "+str(self.numCellsFromNeighbors[neighbor])
            
            return selectedCells

    def _sixtop_cell_reservation_response_centralized_noOverlapping(self,neighbor,numCells,dirNeighbor):
        ''' get a response from the neighbor. '''
         
        with self.dataLock:
           
            #in the parent, numCells are tried to be reserved
           
            # set direction of cells
            if dirNeighbor == self.DIR_TX:
                dir = self.DIR_RX
            else:
                dir = self.DIR_TX
                                    
            ###!!!### if self.DEBUG: print "I am "+str(self.id)+" I have received a request from"+str(neighbor.id)+" my schedule is "+str(self.schedule.keys())+" and he wants cells: "+str(numCells)
            
            #this are all my cells
            allCells = []
            for x in range(0,self.settings.slotframeLength):
                for y in range(0,self.settings.numChans):
		    if (x,y) != (0,0):
		        cell=['0','0']
		        cell[0]=x
		        cell[1]=y
		        allCells.append(cell)
            ###!!!### if self.DEBUG: print " all  cells: "+str(len(allCells))   
	    ###!!!### if self.DEBUG: print " all  cells: "+str(allCells)           
            #these are all my available cells
                    
            
            
            availableCells = []
            ###!!!### if self.DEBUG: print "Avalialbe cells: "+str(len(availableCells))
            for cell in allCells: 
                if not (cell[0],cell[1]) in self.schedule:
                    if not (cell[0],cell[1]) in neighbor.schedule:
			###!!!### if self.DEBUG: print availableCells
                        availableCells.append(cell) 
                        #availableCells.remove([cell[0],cell[1]])
			#print availableCells
            ###!!!### if self.DEBUG: print "After check my schedule Avalialbe cells: "+str(len(availableCells)) 
            ###!!!### if self.DEBUG: print "After check my schedule Avalialbe cells: "+str(availableCells)
            


       
            #this make the scheduler centralized (no collisions)
            
            for neigh in self.engine.motes:
                if neigh != self and neigh != neighbor:
                    #print "I am 3 my signal to "+str(neigh.id)+" is "+str(self.getRSSI(neigh))+" mins: (self, neigh) "+str((self.minRssi,neigh.minRssi))
                    #print "I am "+str(neigh.id)+" my signal to 3 is "+str(neigh.getRSSI(self))+" mins: (self, neigh) "+str((self.minRssi,neigh.minRssi))
                    for cell in neigh.schedule.keys():
                        #assert False
                        if cell != (0,0):			   
                            if [cell[0],cell[1]] in availableCells:				
                                availableCells.remove([cell[0],cell[1]])


                      
            ###!!!### if self.DEBUG: print "Avalialbe cells after check mith all nodes: "+str(len(availableCells))  
            #self.numcellsLearned=len(availableCells)
            ###!!!### if self.DEBUG: print "After check all schedules Avalialbe cells: "+str(availableCells) 
            #print "all  cells: "+str(len(allCells))
            #print "Avalialbe cells: "+str(availableCells)       
            #print "Avoidable cells: "+str(avoidableCells)  
            #initcell=[0,0]
            #availableCells.remove(initcell)
           
            ###!!!### if self.DEBUG: print "all  cells: "+str(len(allCells))
            ###!!!### if self.DEBUG: print "Avalialbe cells: "+str(len(availableCells))
             
            #if I have cells, I try to assign them
            selectedCells={}
            if len(availableCells) > 0:
                random.shuffle(availableCells)
                
               
                #if they request more cells than I have, I try to give them the maxium available
                while len(availableCells) < numCells:
                    numCells=numCells-1 
                
                ranChosen=random.sample(range(0, len(availableCells)), numCells)
                
                #these are my selected cells
                for i in range(numCells):
                    selectedCells[i]=availableCells[ranChosen[i]]
         
                ###!!!### if self.DEBUG: print "I am "+str(self.id)+" and I have selected selected cells are "+str(selectedCells)
                
                cellList              = []
                
                for i,val in selectedCells.iteritems():
                    # log
                    self._log(
                        self.INFO,
                        '[6top] add RX cell ts={0},ch={1} from {2} to {3}',
                        (val[0],val[1],self.id,neighbor.id),
                    )
                    cellList         += [(val[0],val[1],dir)]
                self._tsch_addCells(neighbor,cellList)            
                                    
                # update counters
                if dir==self.DIR_TX:
                    if neighbor not in self.numCellsToNeighbors:
                        self.numCellsToNeighbors[neighbor]     = 0
                    self.numCellsToNeighbors[neighbor]        += len(selectedCells)
                else:
                    if neighbor not in self.numCellsFromNeighbors:
                        self.numCellsFromNeighbors[neighbor]   = 0
                    self.numCellsFromNeighbors[neighbor]      += len(selectedCells)
            
            
            ###!!!### if self.DEBUG: print "So since I am "+str(self.id)+" all my cells are "+str(self.schedule.keys())+" and I have for my neighbor "+str(neighbor.id)+" cells: "+str(self.numCellsFromNeighbors[neighbor])
           
            return selectedCells
            
            
            
            
    def _sixtop_cell_reservation_response_centralized_optimized(self,neighbor,numCells,dirNeighbor):
        ''' get a response from the neighbor. '''
         
        with self.dataLock:
           
            #in the parent, numCells are tried to be reserved
           
            # set direction of cells
            if dirNeighbor == self.DIR_TX:
                dir = self.DIR_RX
            else:
                dir = self.DIR_TX
                                    
            ###!!!### if self.DEBUG: print "I am "+str(self.id)+" I have received a request from"+str(neighbor.id)+" my schedule is "+str(self.schedule.keys())+" and he wants cells: "+str(numCells)
            
            #this are all my cells
            allCells = []
            for x in range(0,self.settings.slotframeLength):
                for y in range(0,self.settings.numChans):
                    cell=['0','0']
                    cell[0]=x
                    cell[1]=y
                    allCells.append(cell)
            ###!!!### if self.DEBUG: print " all  cells: "+str(len(allCells))         
            #these are all my available cells
                    
            
            
            availableCells = []
            #print "Avalialbe cells: "+str(len(availableCells))
            for cell in allCells: 
                if not (cell[0],cell[1]) in self.schedule:
                    if not (cell[0],cell[1]) in neighbor.schedule:
                        availableCells.append(cell) 
                        #print "cell is available: "+str((cell[0],cell[1]))
                        #availableCells.remove([cell[0],cell[1]])
            ###!!!### if self.DEBUG: print "After check my schedule Avalialbe cells: "+str(len(availableCells)) 
            ###!!!### if self.DEBUG: print "After check my schedule Avalialbe cells: "+str(availableCells)
            

            ##improve efficiency
            #print "Checking if cells are really available. Me an my neighbor are: "+str((self.id, neighbor.id))
            collidingCells=[]            
            
#            for cell2 in availableCells:
#                for mote in self.engine.motes:    
#                    if mote != self and mote != neighbor:
#                        #if (self.getRSSI(mote) >= mote.minRssi or mote.getRSSI(self) >= self.minRssi) or (neighbor.getRSSI(mote) >= mote.minRssi or mote.getRSSI(neighbor) >= neighbor.minRssi):
#                        if (self.getRSSI(mote)+(-97-(-105)) >= mote.minRssi or mote.getRSSI(self)+(-97-(-105))  >= self.minRssi ) or (neighbor.getRSSI(mote)+(-97-(-105)) >= mote.minRssi or mote.getRSSI(neighbor)+(-97-(-105))  >= neighbor.minRssi):                            
#                            if mote.schedule.has_key((cell2[0],cell2[1])):
#                                result = [element for element in collidingCells if element[0] == cell2[0] and element[1] == cell2[1]]
#                                if len(result)==0: 
#                                    collidingCells.append(cell2)
#                                    break


	    
            for mote in self.engine.motes:    
                if mote != self and mote != neighbor:
                #if (self.getRSSI(mote) >= mote.minRssi or mote.getRSSI(self) >= self.minRssi) or (neighbor.getRSSI(mote) >= mote.minRssi or mote.getRSSI(neighbor) >= neighbor.minRssi):
                    if (self.getRSSI(mote)+(-97-(-105)) >= mote.minRssi or mote.getRSSI(self)+(-97-(-105))  >= self.minRssi ) or (neighbor.getRSSI(mote)+(-97-(-105)) >= mote.minRssi or mote.getRSSI(neighbor)+(-97-(-105))  >= neighbor.minRssi):
		        for cell2 in availableCells:                            
		            if mote.schedule.has_key((cell2[0],cell2[1])):
		                result = [element for element in collidingCells if element[0] == cell2[0] and element[1] == cell2[1]]
		                if len(result)==0: 
		                    collidingCells.append(cell2)
		                    #break
                                
            ###!!!### if self.DEBUG: print "After check other schedules Avalialbe cells: "+str(len(availableCells)) 
            ###!!!### if self.DEBUG: print "After check other schedules I cant use these cells: "+str(collidingCells)
            
            for cell3 in collidingCells:            
                result = [element for element in availableCells if element[0] == cell3[0] and element[1] == cell3[1]]
                if len(result)==1: 
                    availableCells.remove([cell3[0],cell3[1]])
                    
            ###!!!### if self.DEBUG: print "After check other schedules Avalialbe cells: "+str(availableCells)     

       
   




                        
            ###!!!### if self.DEBUG: print "Avalialbe cells after check mith all nodes: "+str(len(availableCells))  
            #self.numcellsLearned=len(availableCells)
            ###!!!### if self.DEBUG: print "After check all schedules Avalialbe cells: "+str(availableCells) 
            #print "all  cells: "+str(len(allCells))
            #print "Avalialbe cells: "+str(availableCells)       
            #print "Avoidable cells: "+str(avoidableCells)  
            #initcell=[0,0]
            #availableCells.remove(initcell)
           
            ###!!!### if self.DEBUG: print "all  cells: "+str(len(allCells))
            ###!!!### if self.DEBUG: print "Avalialbe cells: "+str(len(availableCells))
             
            #if I have cells, I try to assign them
            selectedCells={}
            if len(availableCells) > 0:
                random.shuffle(availableCells)
                
               
                #if they request more cells than I have, I try to give them the maxium available
                while len(availableCells) < numCells:
                    numCells=numCells-1 
                
                ranChosen=random.sample(range(0, len(availableCells)), numCells)
                
                #these are my selected cells
                for i in range(numCells):
                    selectedCells[i]=availableCells[ranChosen[i]]
         
                ###!!!### if self.DEBUG: print "I am "+str(self.id)+" and I have selected selected cells are "+str(selectedCells)
                
                cellList              = []
                
                for i,val in selectedCells.iteritems():
                    # log
                    self._log(
                        self.INFO,
                        '[6top] add RX cell ts={0},ch={1} from {2} to {3}',
                        (val[0],val[1],self.id,neighbor.id),
                    )
                    cellList         += [(val[0],val[1],dir)]
                self._tsch_addCells(neighbor,cellList)            
                                    
                # update counters
                if dir==self.DIR_TX:
                    if neighbor not in self.numCellsToNeighbors:
                        self.numCellsToNeighbors[neighbor]     = 0
                    self.numCellsToNeighbors[neighbor]        += len(selectedCells)
                else:
                    if neighbor not in self.numCellsFromNeighbors:
                        self.numCellsFromNeighbors[neighbor]   = 0
                    self.numCellsFromNeighbors[neighbor]      += len(selectedCells)
            
            
            #print "So since I am "+str(self.id)+" all my cells are "+str(self.schedule.keys())+" and I have for my neighbor "+str(neighbor.id)+" cells: "+str(self.numCellsFromNeighbors[neighbor])
            
            return selectedCells





    def _sixtop_cell_reservation_response_centralized_optimized2(self,neighbor,numCells,dirNeighbor):
        ''' get a response from the neighbor. If there are not numCells available, returns 0 '''
	with self.dataLock:
	    #in the parent, numCells are tried to be reserved
	   
	    # set direction of cells
	    if dirNeighbor == self.DIR_TX:
	        dir = self.DIR_RX
	    else:
	        dir = self.DIR_TX
	                            
	    ###!!!### if self.DEBUG: print "I am "+str(self.id)+" I have received a request from"+str(neighbor.id)+" my schedule is "+str(self.schedule.keys())+" and he wants cells: "+str(numCells)
	    ###!!!### if self.DEBUG: print "The schedule of my neighbor is: "+str(neighbor.schedule.keys())
	    #this are all my cells
	    allCells = []
	    for x in range(0,self.settings.slotframeLength):
	        for y in range(0,self.settings.numChans):
	            cell=['0','0']
	            cell[0]=x
	            cell[1]=y
	            allCells.append(cell)
	    ###!!!### if self.DEBUG: print " all  cells: "+str(len(allCells))         
	    #these are all my available cells
	            
	    
	    
	    availableCells = []
	    #print "Avalialbe cells: "+str(len(availableCells))
	    for cell in allCells: 
	        if not (cell[0],cell[1]) in self.schedule:
	            if not (cell[0],cell[1]) in neighbor.schedule:
	                availableCells.append(cell) 
	                #print "cell is available: "+str((cell[0],cell[1]))
	                #availableCells.remove([cell[0],cell[1]])
	    ###!!!### if self.DEBUG: print "After check my schedule Avalialbe cells: "+str(len(availableCells)) 
	    ###!!!### if self.DEBUG: print "After check my schedule Avalialbe cells: "+str(availableCells)
	    
     

	    ##improve efficiency
	    #print "Checking if cells are really available. Me an my neighbor are: "+str((self.id, neighbor.id))
	    collidingCells=[]            
	    
	    for cell2 in availableCells:
	        for mote in self.engine.motes:    
	            if mote != self and mote != neighbor:
			#if cell2[0]==3 and cell2[1]==0:
#				print "From "+str(self.id)+" to "+str(mote.id)+" signal: "+str(self.getRSSI(mote))
#                        	print "From "+str(neighbor.id)+" to "+str(mote.id)+" signal: "+str(neighbor.getRSSI(mote))
#				print "From "+str(mote.id)+" to "+str(self.id)+" signal: "+str(self.getRSSI(mote))
#                        	print "From "+str(mote.id)+" to "+str(neighbor.id)+" signal: "+str(neighbor.getRSSI(mote))
#				for ((ts,ch),c) in mote.schedule.items() :
#					if (ts==3) and (ch==0):
#						print "From "+str(c['neighbor'].id)+" to "+str(neighbor.id)+" signal: "+str(neighbor.getRSSI(c['neighbor']))
#						print "From "+str(c['neighbor'].id)+" to "+str(self.id)+" signal: "+str(self.getRSSI(c['neighbor']))
#			if (self.id==4 and neighbor.id==8) or (self.id==0 and neighbor.id==6):
#                                if mote.id==0 or mote.id==6 or mote.id==8 or mote.id==4:
#                                    print "From "+str(self.id)+" to "+str(mote.id)+" signal: "+str(self.getRSSI(mote))
#                                    print "From "+str(neighbor.id)+" to "+str(mote.id)+" signal: "+str(neighbor.getRSSI(mote))
	                if (self.getRSSI(mote) >= mote.minRssi or mote.getRSSI(self) >= self.minRssi) or (neighbor.getRSSI(mote) >= mote.minRssi or mote.getRSSI(neighbor) >= neighbor.minRssi):
                            
	                #if (self.getRSSI(mote)+(-97-(-105)) >= mote.minRssi or mote.getRSSI(self)+(-97-(-105))  >= self.minRssi ) or (neighbor.getRSSI(mote)+(-97-(-105)) >= mote.minRssi or mote.getRSSI(neighbor)+(-97-(-105))  >= neighbor.minRssi): 
			                               
                	    if mote.schedule.has_key((cell2[0],cell2[1])):
				#print "I cant use cell "+str(cell2)
#				print "From "+str(self.id)+" to "+str(mote.id)+" signal: "+str(self.getRSSI(mote))
#                                print "From "+str(neighbor.id)+" to "+str(mote.id)+" signal: "+str(neighbor.getRSSI(mote))
#				print "From "+str(mote.id)+" to "+str(self.id)+" signal: "+str(self.getRSSI(mote))
#                                print "From "+str(mote.id)+" to "+str(neighbor.id)+" signal: "+str(neighbor.getRSSI(mote))
                                result = [element for element in collidingCells if element[0] == cell2[0] and element[1] == cell2[1]]
                                if len(result)==0: 
                                    collidingCells.append(cell2)
                                    break
	                        
	    ###!!!### if self.DEBUG: print "After check other schedules Avalialbe cells: "+str(len(availableCells)) 
	    ###!!!### if self.DEBUG: print "After check other schedules I cant use these cells: "+str(collidingCells)
	    
	    for cell3 in collidingCells:            
	        result = [element for element in availableCells if element[0] == cell3[0] and element[1] == cell3[1]]
	        if len(result)==1: 
	            availableCells.remove([cell3[0],cell3[1]])
	            
	    ###!!!### if self.DEBUG: print "After check other schedules Avalialbe cells: "+str(availableCells)     

       
   




	                
	    ###!!!### if self.DEBUG: print "Avalialbe cells after check mith all nodes: "+str(len(availableCells))  
	    #self.numcellsLearned=len(availableCells)
	    ###!!!### if self.DEBUG: print "After check all schedules Avalialbe cells: "+str(availableCells) 
	    #print "all  cells: "+str(len(allCells))
	    #print "Avalialbe cells: "+str(availableCells)       
	    #print "Avoidable cells: "+str(avoidableCells)  
	    #initcell=[0,0]
	    #availableCells.remove(initcell)
	   
	    ###!!!### if self.DEBUG: print "all  cells: "+str(len(allCells))
	    ###!!!### if self.DEBUG: print "Avalialbe cells: "+str(len(availableCells))
	     
	    #if I have cells, I try to assign them
	    selectedCells={}
            if len(availableCells) > 0:
	        random.shuffle(availableCells)
	        
	       
	        #if they request more cells than I have, I try to give them the maxium available
	        while len(availableCells) < numCells:
	            numCells=numCells-1 
	        
	        ranChosen=random.sample(range(0, len(availableCells)), numCells)
	        
	        #these are my selected cells
	        for i in range(numCells):
	            selectedCells[i]=availableCells[ranChosen[i]]
	 
	        ###!!!### if self.DEBUG: print "I am "+str(self.id)+" and I have selected selected cells are "+str(selectedCells)
	        
	        cellList              = []
	        
	        for i,val in selectedCells.iteritems():
	            # log
	            self._log(
	                self.INFO,
	                '[6top] add RX cell ts={0},ch={1} from {2} to {3}',
	                (val[0],val[1],self.id,neighbor.id),
	            )
	            cellList         += [(val[0],val[1],dir)]
	        self._tsch_addCells(neighbor,cellList)            
	                            
	        # update counters
	        if dir==self.DIR_TX:
	            if neighbor not in self.numCellsToNeighbors:
	                self.numCellsToNeighbors[neighbor]     = 0
	            self.numCellsToNeighbors[neighbor]        += len(selectedCells)
	        else:
	            if neighbor not in self.numCellsFromNeighbors:
	                self.numCellsFromNeighbors[neighbor]   = 0
	            self.numCellsFromNeighbors[neighbor]      += len(selectedCells)
            
            return selectedCells
	    
	    #print "So since I am "+str(self.id)+" all my cells are "+str(self.schedule.keys())+" and I have for my neighbor "+str(neighbor.id)+" cells: "+str(self.numCellsFromNeighbors[neighbor])
        	   
#            else:
#                if self.DEBUG: print "I am "+str(self.id)+" and the available cells was "+str(len(availableCells))
#                return 0
    
    def _sixtop_cell_deletion_sender(self,neighbor,tsList):
        with self.dataLock:
            
            #print "REMOVING LINK: "+str(self.id)+"-> "+str(neighbor.id)+" and the cells: "
#            for ((ts,ch),cell) in self.schedule.iteritems():
#                if cell['neighbor'] == neighbor:
#                    print "The cell for: "+str(cell['neighbor'].id)+" is "+str(ts)+","+str(ch)
            #print tsList
            ###!!!### if self.DEBUG: print " I m "+str(self.id)+" SEND My cells to "+str(neighbor.id)+" are "+str(self.numCellsToNeighbors[neighbor])
            # log
            self._log(
                self.INFO,
                "[6top] remove timeslots={0} with {1}",
                (tsList,neighbor.id),
            )
            self._tsch_removeCells2(
                neighbor     = neighbor,
                tsList       = tsList,
            )
            ###!!!### if self.DEBUG: print "[6top]{2}: remove cells={0} with {1}".format(tsList,neighbor.id,self.id)
               
            
            ###!!!### if self.DEBUG: print "I have TX cells: "+str(len(self.schedule.items()))
            ###!!!### if self.DEBUG: print "I am going to remove TX cells: "+str(len(tsList))
            
            ###!!!### if self.DEBUG: print "I am "+str(self.id)+". Now I0m going to delete in the receiver side: "+str(tsList)+ " have been selected for remove (Sender)"
            neighbor._sixtop_cell_deletion_receiver(self,tsList)
            ###!!!### if self.DEBUG: print "My cells to "+str(neighbor.id)+" are "+str(self.numCellsToNeighbors[neighbor])+"-------------------------------------------------------------------------------"
            self.numCellsToNeighbors[neighbor]       -= len(tsList)
            ###!!!### if self.DEBUG: print "My cells to "+str(neighbor.id)+" are "+str(self.numCellsToNeighbors[neighbor])+"-------------------------------------------------------------------------------"
            assert self.numCellsToNeighbors[neighbor]>=0
            
            
            ###!!!### if self.DEBUG: print "I am "+str(self.id)+" my schedule after Deletion is "+str(self.schedule.keys())
            ###!!!### if self.DEBUG: print "and my neighbor "+str(neighbor.id)+" my schedule after adding is "+str(neighbor.schedule.keys())   
            ###!!!### if self.DEBUG: print "After delete :"+str(tsList)
            ###!!!### if self.DEBUG: print "We are sharing the cells:"+str(list(set(self.schedule.keys()).intersection(neighbor.schedule.keys())))
    
    def _sixtop_cell_deletion_receiver(self,neighbor,tsList):
        with self.dataLock:
           
            #for i in tsList:
           
#            print "I am "+str(self.id)+" My neighbor "+str(neighbor.id)+ " wants me to delete some cells (Recv)"
#            print str(self.id)+": these cells are "+str(tsList)+ " wants me to delete some cells (Recv)"
#            print str(self.id)+": my cells are "+str(self.schedule.keys())
#            for ((ts,ch),c) in self.schedule.items(): 
#                if (ts,ch) != (0,0): 
#                    print str(self.id)+": cell "+str((ts,ch))+" is for the neighbor "+str(c['neighbor'].id)
#                else:   
#                    print str(self.id)+": cell "+str((ts,ch))+" is for the neighbor "+str(c['neighbor'])
#                
#            print str(self.id)+": the number of cells for this nieghbor is "+str(self.numCellsFromNeighbors[neighbor])
            
            
            #if self.numCellsFromNeighbors[neighbor]:
            #print self.numCellsFromNeighbors
            #for neigh in self.numCellsFromNeighbors.keys():
                #print "My cells to are "+str(neigh.id)
                #print "My cells to "+str(neigh)+" are "+str(self.numCellsFromNeighbors[neigh])
            #else:
                #print "Dont have any cell with this neighbor"
            
            
            
            self._tsch_removeCells2(
                neighbor     = neighbor,
                tsList       = tsList,
            )
            
            #print "I am "+str(self.id)+" RECV My number cells to "+str(neighbor.id)+" are "+str(self.numCellsToNeighbors)+"-------------------------------------------------------------------------------"
            #for neighbor in self.numCellsToNeighbors:
                #print "I have this neighbor: "+str(neighbor.id)
            if self.numCellsFromNeighbors[neighbor]:
                self.numCellsFromNeighbors[neighbor]     -= len(tsList)
            #print "My cells to "+str(neighbor.id)+" are "+str(self.numCellsToNeighbors[neighbor])+"-------------------------------------------------------------------------------"
           
            assert self.numCellsFromNeighbors[neighbor]>=0
            
    
    def _sixtop_removeCells(self,neighbor,numCellsToRemove):
        '''
        Finds cells to neighbor, and remove it.
        '''
        #self.numReqCells=self.numReqCells-numCellsToRemove
        #self.numDeniedCells=self.numDeniedCells-numCellsToRemove
        # get cells to the neighbors
        scheduleList = []
        
        # worst cell removing initialized by theoretical pdr
        for ((ts,ch),cell) in self.schedule.iteritems():
            if cell['neighbor']==neighbor and cell['dir']==self.DIR_TX:
                cellPDR           = (float(cell['numTxAck'])+(self.getPDR(neighbor)*self.NUM_SUFFICIENT_TX))/(cell['numTx']+self.NUM_SUFFICIENT_TX)
                scheduleList     += [(ts,ch,cell['numTxAck'],cell['numTx'],cellPDR)]
                #print str(scheduleList)
        # introduce randomness in the cell list order
        random.shuffle(scheduleList)
               
        if not self.settings.sixtopNoRemoveWorstCell:
            # triggered only when worst cell selection is due
            # (cell list is sorted according to worst cell selection)
            scheduleListByPDR     = {}
            for tscell in scheduleList:
                if not scheduleListByPDR.has_key(tscell[3]):
                    scheduleListByPDR[tscell[3]]=[]
                scheduleListByPDR[tscell[3]]+=[tscell]
            rssi                  = self.getRSSI(neighbor)
            theoPDR               = Topology.Topology.rssiToPdr(rssi)
            scheduleList          = []
            for pdr in sorted(scheduleListByPDR.keys()):
                if pdr<theoPDR:
                    scheduleList += sorted(scheduleListByPDR[pdr], key=lambda x: x[2], reverse=True)
                else:
                    scheduleList += sorted(scheduleListByPDR[pdr], key=lambda x: x[2])        
            
        # remove a given number of cells from the list of available cells (picks the first numCellToRemove)
        tsList=[]
        for tscell in scheduleList[:numCellsToRemove]:
            
            # log
            self._log(
                self.INFO,
                "[otf] remove cell ts={0} to {1} (pdr={2:.3f})",
                ((tscell[0],tscell[1]),neighbor.id,tscell[3]),
            )
            tsList += [(tscell[0],tscell[1])]
        
        # remove cells
#        if self.id == 38:
        #print "I'm "+str(self.id)+" and I'm going to delete "+str(tsList)+" towards "+str(neighbor.id)
        self._sixtop_cell_deletion_sender(neighbor,tsList)
    
    #===== tsch
    
    def _tsch_enqueue(self,packet):
#        if packet['payload'][0]==24:
#            print "I am "+str(self.id)+"enqueing from "+str(packet['payload'][0])
        if not self.preferredParent:
            # I don't have a route
            print "No route!"
            # increment mote state
            self._stats_incrementMoteStats('droppedNoRoute')
            assert False
            return False
        
        elif not self.getTxCells():
            # I don't have any transmit cells
            ###!!!### if self.DEBUG: print "No tx cells!"
            # increment mote state
            #assert False # here never can be reached
            self._stats_incrementMoteStats('droppedNoTxCells')

            return False
        
        elif len(self.txQueue)==self.TSCH_QUEUE_SIZE:
            # my TX queue is full
#            if packet['payload'][0]==24:
#                print "I am "+str(self.id)+"queue full! from "+str(packet['payload'][0])
            # update mote stats
            self._stats_incrementMoteStats('droppedQueueFull')
            #if packet['payload'][0]==24:
            #self._stats_incrementMoteStats('droppedAppFailedEnqueue')

            return False
        
        else:
            # all is good
            
            # enqueue packet
            self.txQueue    += [packet]
#            if packet['payload'][0]==24:
#                print "I am "+str(self.id)+"enqueing from "+str(packet['payload'][0])+" OK"
            return True
    
    def _tsch_schedule_activeCell(self):
        
        asn        = self.engine.getAsn()
        tsCurrent  = asn%self.settings.slotframeLength
        
        #print "ASN is "+str(asn)
        #print "ASN is "+str(tsCurrent)
        
        # find closest active slot in schedule
        with self.dataLock:
            
            if not self.schedule:
                ###!!!### if self.DEBUG: print "Nothing to do"
                self.engine.removeEvent(uniqueTag=(self.id,'_tsch_action_activeCell'))
                return
            
            tsDiffMin             = None
            for ((ts,ch),cell) in self.schedule.items():
                if   ts==tsCurrent:
                    tsDiff        = self.settings.slotframeLength
                elif ts>tsCurrent:
                    tsDiff        = ts-tsCurrent
                elif ts<tsCurrent:
                    tsDiff        = (ts+self.settings.slotframeLength)-tsCurrent
                else:
                    raise SystemError()
                
                if (not tsDiffMin) or (tsDiffMin>tsDiff):
                    tsDiffMin     = tsDiff
        
            
        # schedule at that ASN
        ###!!!### if self.DEBUG: print "I'm mote "+str(self.id)+" i am in the asn "+str(asn)+ "that is ts="+str(ts)+" next active slot is "+str(asn+tsDiffMin)+" with diff "+str(tsDiffMin)
        self.engine.scheduleAtAsn(
            asn         = asn+tsDiffMin,
            cb          = self._tsch_action_activeCell,
            uniqueTag   = (self.id,'_tsch_action_activeCell'),
            priority    = 0,
        )
        
    
    def _tsch_action_activeCell(self):
        '''
        active slot starts. Determine what todo, either RX or TX, use the propagation model to introduce
        interference and Rx packet drops.
        '''
        
        asn = self.engine.getAsn()
        ts  = asn%self.settings.slotframeLength
        
        ###!!!### if self.DEBUG: print "I'm mote "+str(self.id)+" i am in the asn "+str(asn)+ "that is ts="+str(ts)
        
        #print "I'm mote "+str(self.id)+" and my good neighbors are:"
        #print "There are nodes: "+str(len(self._myGoodNeigbors())+1)        
        with self.dataLock:
            
            self.pktToSend = []
         
            tss=[row[0] for row in self.schedule.keys()]
            #chs=[row[1] for row in self.schedule.keys()]

            assert ts in tss

            
            numberPacketSentInThisTs=0
            #i_ch=0
            for i_ch in range(0,self.settings.numChans):
                if (ts,i_ch) in self.schedule.keys():
                    cell = self.schedule[(ts,i_ch)]
                    #if ((ts == 0) & (i_ch == 0)):
                    if (cell['dir']==self.DIR_SHARED):
                        if asn > ((2*self.settings.slotframeLength)-1):
                                                  
                            
                            if i_ch == (self.myBrCh) and ts==(self.myBrTs):    
    #                            if self.numberOfWaitings==0:
    #                                self.numberOfWaitings=random.randint(0,self.maxWin)
    #                                #print "I'm mote. My Win is "+str(self.maxWin)+" waitings= "+str(self.numberOfWaitings)
    #                            else:
    #                                self.numberOfWaitings=self.numberOfWaitings-1
                               
                                
                                ###!!!### if self.DEBUG: print "I'm mote "+str(self.id)+" and my waitings are "+str(self.numberOfWaitings)+" my br cell is "+str((self.myBrTs,self.myBrCh))
                                
                               
                                assert cell['dir']==self.DIR_SHARED
                                
                                if self.numberOfWaitings==0:
                               
                                    #self.numberOfWaitings=random.randint(0,self.maxWin)
                                    #self.numberOfWaitings=self.id%self.maxWin
                               
                                    #chance=random.random()                                                                        
                                    #if chance<=:
                                        
                                    #if self.settings.overlappingBrCells==0:    
                                    self.numberOfWaitings=self.maxWin-1
                                    #else:
                                        #assert self.settings.overlappingBrCells < 1
                                        #assert self.settings.overlappingBrCells > 0
                                        #self.numberOfWaitings=random.randint(0,self.maxWin)
                                    
                                    #print "There are nodes: "+str(len(self._myGoodNeigbors())+1) 
                                    #print "I'm mote "+str(self.id)+" Broadcast Collision detected! somebody else is also broadcasting"
                                    #print "I'm mote "+str(self.id)+" BROADCAST!"
                                    assert i_ch == self.myBrCh
                                    assert ts == self.myBrTs
                                    cell = self.schedule[(ts,i_ch)]
                                    
                                    #print "I am "+str(self.id)+" and I am going to transmit BC at "+str((ts,i_ch))
                                    #cell['dir']=self.DIR_TX
                                    #if self.id==12 or self.id==1 or self.id==44 or self.id==17:
                                    
                                    ###!!!### if self.DEBUG: print "I'm "+str(self.id)+" It is necessary TX BROADCAST in Ts "+str(ts)+" and channel "+str(cell['ch'])
                                    ###!!!### if self.DEBUG: print "My schedule is "+str(self.schedule.keys())
                                    
                                    
#                                    for neighbor in self._myNeigbors():
#                                        print "I have neighbor "+str(neighbor.id)+" I am mote "+str(self.id)
#                                        print "My pdr with this neighbor is "+str(self.getPDR(neighbor))
                                    
                                    schedulingPacket = {
                                                'asn':            self.engine.getAsn(),
                                                'type':           self.SIXP_TYPE_MYSCHEDULE,
                                                'payload':        [self.id,self.engine.getAsn(),self.schedule], # the payload is used for latency and number of hops calculation
                                                'retriesLeft':    self.TSCH_MAXTXRETRIES
                                                }
        #                            print "Sending Packet towards: "
        ##                            for n in self._myNeigbors():
        ##                                print n.id
                                    self.schedule[(ts,i_ch)]['waitingfor']=self.DIR_SHARED
                                    
                                    self.engine.bcstTransmitted+=1                                
                                    
                                    #print "channela is "+str(cell['ch'])
                                    self.propagation.startTx(
                                                    channel   = cell['ch'],
                                                    type      = schedulingPacket['type'],
                                                    smac      = self,
                                                    dmac      = self._myNeigbors(),
                                                    payload   = schedulingPacket['payload'],
                                                )
                                    
                                    # indicate that we're waiting for the TX operation to finish
                                                             
                                    # log charge usage
                                    self._logChargeConsumed(self.CHARGE_TxData_uC)                        
                                else:
                                    #if it is not my turn to transmit broadcast, I try to receive                                    
                                    
                                    self.numberOfWaitings=self.numberOfWaitings-1
                                    self.schedule[(ts,i_ch)]['waitingfor']=self.DIR_SHARED
                                    self.propagation.startRx(
                                        mote          = self,
                                        channel       = cell['ch'],
                                    )
                                
                            else:
                                #cell['dir']=self.DIR_RX
                                #print "I'm mote "+str(self.id)+" and my waitings are "+str(self.numberOfWaitings):
                                #if (i_ch == (int(self.id) % self.settings.numChans)):
                                    
#                                    print " This channel is "+str(i_ch)
#                                    print " but I have to transmit broadcast in: "+str(self.id % self.settings.numChans)
                                #else:
#                                    print " This channel is "+str(i_ch)
#                                    print " but I have to transmit broadcast in: "+str(self.id % self.settings.numChans)
                                ###!!!### if self.DEBUG: print "I'm "+str(self.id)+" ACTIVECELL. It is necessary RX a broadcast in Ts "+str(ts)+" and channel "+str(i_ch)
                                self.schedule[(ts,i_ch)]['waitingfor']=self.DIR_SHARED
                                self.propagation.startRx(
                                    mote          = self,
                                    channel       = cell['ch'],
                                )
                                 
                    
                
                    else:    
                        
                        ###!!!### if self.DEBUG: print "I'm "+str(self.id)+" ACTIVECELL. It is necessary do something in Ts "+str(ts)+" and channel "+str(i_ch)
                        cell = self.schedule[(ts,i_ch)]
                        assert cell
                        
                        if  cell['dir']==self.DIR_RX:
                            ###!!!### if self.DEBUG: print "I'm "+str(self.id)+" ACTIVECELL. It is necessary RX in Ts "+str(ts)+" and channel "+str(i_ch)
          
                            self.schedule[(ts,i_ch)]['waitingfor']=self.DIR_RX
                            self.propagation.startRx(
                                mote          = self,
                                channel       = cell['ch'],
                            ) 
                    
                        elif cell['dir']==self.DIR_TX:
                            ###!!!### if self.DEBUG: print "I'm "+str(self.id)+" ACTIVECELL. It is necessary TX in Ts "+str(ts)+" and channel "+str(i_ch)
                            
                            
                            
                            ###!!!### if self.DEBUG: print "I'm "+str(self.id)+" Preparing to send. The queue is "+str(len(self.txQueue))
                            ###!!!### if self.DEBUG: print "I'm "+str(self.id)+" Preparing to send. The prepared packets are "+str(len(self.pktToSend))
                            if self.txQueue:
                                if len(self.txQueue) >= (numberPacketSentInThisTs+1):
                                    ###!!!### if self.DEBUG: print "I have in the queue: "+str(self.txQueue)+" .In this TS i want to send "+str(numberPacketSentInThisTs)
                                    self.pktToSend.append(self.txQueue[numberPacketSentInThisTs])
                                    ###!!!### if self.DEBUG: print "Im going to sent "+str(self.txQueue[numberPacketSentInThisTs])
                            
                            # send packet
                            if bool(self.pktToSend) == True:
                                if len(self.pktToSend) >= (numberPacketSentInThisTs+1):
                                        ###!!!### if self.DEBUG: print str(self.id)+"Preparing packet "+str(self.pktToSend[numberPacketSentInThisTs]['payload'])
                                        cell['numTx'] += 1
                                        self.numTransmissions += 1
                                        #cell['waitingfor']=self.DIR_TX
                                        self.schedule[(ts,i_ch)]['waitingfor']=self.DIR_TX
                                        #print "channel is "+str(cell['ch'])                                        
                                        
                                        self.propagation.startTx(
                                            channel   = cell['ch'],
                                            type      = self.pktToSend[numberPacketSentInThisTs]['type'],
                                            smac      = self,
                                            dmac      = cell['neighbor'],
                                            payload   = self.pktToSend[numberPacketSentInThisTs]['payload'],
                                        )
                    
                                        # indicate that we're waiting for the TX operation to finish
                                                                 
                                        # log charge usage
                                        self._logChargeConsumed(self.CHARGE_TxDataRxAck_uC)
                                        numberPacketSentInThisTs=numberPacketSentInThisTs+1
                        
                #print "Scheduling the next cell. I'm "+str(self.id)
                
                #print "I am "+str(self.id)+" and my schedule is "+str(self.schedule)
                    ###!!!### if self.DEBUG: print "I'm mote "+str(self.id)+" Finishing the asn "+str(asn)+ "that is ts="+str(ts)+" scheduling next ts"
                    self._tsch_schedule_activeCell()
    
    def _tsch_addCells(self,neighbor,cellList):
        ''' adds cell(s) to the schedule '''
        
        with self.dataLock:
            
            ###!!!### if self.DEBUG: print "I am "+str(self.id)+" I am going to add "+str(cellList)+" the current asn is "+str(self.engine.asn)
            for cell in cellList:
                #emunicio
                #print str(cell)
                #print str(self.id)+" CELL: TS:"+str(cell[0])+" CH:"+str(cell[1])
                
                assert cell
                #assert cell[1] in self.matrix.get(cell[0])
                
                self.schedule[(cell[0],cell[1])] = {
                    'ts':                        cell[0],
                    'ch':                        cell[1],
                    'dir':                       cell[2],
                    'neighbor':                  neighbor,
                    'numTx':                     0,
                    'busy':                      0,
                    'numTxAck':                  0,
                    'broadCell_id':              None,
                    'numRx':                     0,
                    'history':                   [],
                    'waitingfor':                None,
                    'rxDetectedCollision':       False,
                    'debug_canbeInterfered':     [],                      # [debug] shows schedule collision that can be interfered with minRssi or larger level 
                    'debug_interference':        [],                      # [debug] shows an interference packet with minRssi or larger level 
                    'debug_lockInterference':    [],                      # [debug] shows locking on the interference packet
                    'debug_cellCreatedAsn':      self.engine.getAsn(),    # [debug]
                }
                
                #print "Adding new cell"+str(self.schedule[(cell[0],cell[1])])+" in mote "+str(self.id)+" to "+str(self.schedule[(cell[0],cell[1])].get('neighbor').id )
                # log
                self._log(
                    self.INFO,
                    "[tsch] add cell ts={0} ch={1} dir={2} with {3}",
                    (cell[0],cell[1],cell[2],neighbor.id),
                )

#            if len(cellList) ==0:
#                print "NO cells!"
#                assert False
            ###!!!### if self.DEBUG: print str(self.id)+" MATRIX"+str(self.schedule.keys())
            self._tsch_schedule_activeCell()
            
            
    def _tsch_removeCells2(self,neighbor,tsList):
        ''' removes cell(s) from the schedule '''
        #self.engine.pauseAtAsn(self.engine.asn+2)
        #print "PAUSE--------------------------"
        with self.dataLock:
            # log
            self._log(
                self.INFO,
                "[tsch] remove timeslots={0} with {1}",
                (tsList,neighbor.id),
            )
            
                    
            ###!!!### if self.DEBUG: print "I am "+str(self.id)+" Before deletion "+str(self.schedule.keys())
            ###!!!### if self.DEBUG: print "I am asked to delete"+str(tsList)+" by "+str(neighbor.id)
            for ts,ch in tsList:
                assert (ts,ch) in self.schedule
               
                del self.schedule[(ts,ch)]
            ###!!!### if self.DEBUG: print "I am "+str(self.id)+" After deletion "+str(self.schedule.keys())
                
            self._tsch_schedule_activeCell()
    
    #===== radio
    
    def radio_txDone(self,isACKed,isNACKed):
        '''end of tx slot'''
        #print "TXDONE function"
        asn   = self.engine.getAsn()
        ts    = asn%self.settings.slotframeLength
        
        with self.dataLock:
            tss=[row[0] for row in self.schedule.keys()]
            assert ts in tss

                    
            i_ch=0
            for i_ch in range(self.settings.numChans):
                if (ts,i_ch) in self.schedule.keys():        
                    #if type==self.SIXP_TYPE_MYSCHEDULE:
                        #self.schedule[(0,0)]['waitingfor']=None
                        
                    if self.schedule[(ts,i_ch)]['waitingfor']==self.DIR_TX:

                        
                        ###!!!### if self.DEBUG: print str(self.id)+" TXDONE. Notification of TX ok in Ts "+str(ts)+" and channel "+str(i_ch)+ " waiting for is "+str(self.schedule[(ts,i_ch)]['waitingfor'])

                        assert self.schedule[(ts,i_ch)]['dir']==self.DIR_TX
                        assert self.schedule[(ts,i_ch)]['waitingfor']==self.DIR_TX

                        if isACKed:
#                            if self.id==17:
#                                print "I am 17 and I have sent a packet to "+str(self.schedule[(ts,i_ch)]['neighbor'].id)
#                                print "I am using the cell "+str((ts,i_ch))+" and detected collision: "+str(self.schedule[(ts,i_ch)]['rxDetectedCollision'])
#                                if ts==1 and i_ch==1:
#                                    print self.engine.asn
#                                    assert False
                            # ACK received
                            #print "ACK RECEIVED"
                            # update schedule stats
                            self.schedule[(ts,i_ch)]['numTxAck'] += 1
                            
                            # update history
                            self.schedule[(ts,i_ch)]['history'] += [1]
                            
                            # update queue stats
                            self._stats_logQueueDelay(asn-self.pktToSend[0]['asn'])
                            
                            # time correction
                            if self.schedule[(ts,i_ch)]['neighbor'] == self.preferredParent:
                                #print "Updating time myself: "+str(self.id)+" with "+str(asn)
                                self.timeCorrectedSlot = asn
                            
                            # remove packet from queue
                            ###!!!### if self.DEBUG: print str(self.id)+" has sent a packet."+str(self.pktToSend[0]['payload'])+" The queue was "+str(self.txQueue)
                            self.txQueue.remove(self.pktToSend[0])
                            self.pktToSend.remove(self.pktToSend[0])
                            
                                                        
                            
                            ###!!!### if self.DEBUG: print str(self.id)+" has remove packet from the queue. Now The queue is len:"+str(self.txQueue)
                            ###!!!### if bool(self.pktToSend) == True:
                                ###!!!### if self.DEBUG: print str(self.id)+" Next packet to be expected is "+str(self.pktToSend[0]['payload'])
                            ###!!!### else:
                                ###!!!### if self.DEBUG: print str(self.id)+" The queue is empty now "
                            #self.numWaitingForsTX= self.numWaitingForsTX -1
                        elif isNACKed:  #when fails in enqueue packet
                            
                            # NACK received
                            ###!!!### if self.DEBUG: print "NACK RECEIVED"
                            # update schedule stats as if it were successfully transmitted
                            self.schedule[(ts,i_ch)]['numTxAck'] += 1
                            #print "NACK RECEIVED"
                            #assert False
                            # update history
                            self.schedule[(ts,i_ch)]['history'] += [1]
                            
                            # time correction
                            if self.schedule[(ts,i_ch)]['neighbor'] == self.preferredParent:
                                #print "Updating time myself: "+str(self.id)+" with "+str(asn)
                                self.timeCorrectedSlot = asn

                            #print str(self.id)+" has recived a NACK."+str(self.pktToSend[0]['payload'])+" The queue was "+str(len(self.txQueue))                         
                            
			    #remove this part because I consider that a packet received is a good MAC tx even if the queue is full
                            
			    # decrement 'retriesLeft' counter associated with that packet
                            #i = self.txQueue.index(self.pktToSend[0])
                            #if self.txQueue[i]['retriesLeft'] > 0:
                                #self.txQueue[i]['retriesLeft'] -= 1
                            
                            # drop packet if retried too many time
                            #if self.txQueue[i]['retriesLeft'] == 0:
                                
                                #if  len(self.txQueue) == self.TSCH_QUEUE_SIZE:
#                            if self.pktToSend[0]['payload'][0]==24:
#                                print str(self.id)+" Packet drop in "+str((ts,i_ch))
                            # update mote stats
                            #ojo
                            #self._stats_incrementMoteStats('droppedMacRetries')
                            #print str(self.pktToSend[0]['payload'][0])
#                            if self.pktToSend[0]['payload'][0]==24:
#                                self._stats_incrementMoteStats('droppedAppFailedEnqueue')
                            #print "DROP!"
                            #print str(self.id)+" has sent a packet. The queue was "+str(len(self.txQueue))
                            # remove packet from queue
                            self.txQueue.remove(self.pktToSend[0])
                            self.pktToSend.remove(self.pktToSend[0])
                            #print str(self.id)+" has remove packet from the queue. The queue is "+str(len(self.txQueue))
                            #self.numWaitingForsTX= self.numWaitingForsTX -1


			    #			    #remove this part because I consider that a packet received is a good MAC tx even if the queue is full
#                            # decrement 'retriesLeft' counter associated with that packet
#                            i = self.txQueue.index(self.pktToSend[0])
#                            if self.txQueue[i]['retriesLeft'] > 0:
#                                self.txQueue[i]['retriesLeft'] -= 1
#                            
#                            # drop packet if retried too many time
#                            if self.txQueue[i]['retriesLeft'] == 0:
#                                
#                                if  len(self.txQueue) == self.TSCH_QUEUE_SIZE:
#                                    if self.DEBUG: print str(self.id)+" Packet drop in "+str((ts,i_ch))
#                                    # update mote stats
#                                    #ojo
#                                    #self._stats_incrementMoteStats('droppedMacRetries')
#                                    self._stats_incrementMoteStats('droppedAppFailedEnqueue')
#                                    #print "DROP!"
#                                    #print str(self.id)+" has sent a packet. The queue was "+str(len(self.txQueue))
#                                    # remove packet from queue
#                                    self.txQueue.remove(self.pktToSend[0])
#                                    self.pktToSend.remove(self.pktToSend[0])
#                                    #print str(self.id)+" has remove packet from the queue. The queue is "+str(len(self.txQueue))
#                                    #self.numWaitingForsTX= self.numWaitingForsTX -1

                        else:
                            # neither ACK nor NACK received
                            #print "NO ACK neither NACK received at "+str((isNACKed,isACKed))
                            # update history
                            self.schedule[(ts,i_ch)]['history'] += [0]

                            # decrement 'retriesLeft' counter associated with that packet
                            i = self.txQueue.index(self.pktToSend[0])
                            if self.txQueue[i]['retriesLeft'] > 0:
                                self.txQueue[i]['retriesLeft'] -= 1
                            
                            
                            #debug problem with MAC drops
                            #print "I am "+str(self.id)+"sending packet "+str(self.txQueue[i]['payload'])+" to "+str(self.schedule[(ts,i_ch)]['neighbor'].id)+" using cell "+str((ts,i_ch))+"There are attempts left: "+str(self.txQueue[i]['retriesLeft'])
                            #print "I am "+str(self.id)+"sending packet "+str(self.pktToSend[0]['payload'])+" to "+str(self.schedule[(ts,i_ch)]['neighbor'].id)+" using cell "+str((ts,i_ch))+"There are attempts left: "+str(self.txQueue[i]['retriesLeft'])

                            #print "I am "+str(self.id)+"sending packet "+str((self.txQueue[i]['payload'],self.txQueue[i]['retriesLeft']))+" to "+str(self.schedule[(ts,i_ch)]['neighbor'].id)+" using cell "+str((ts,i_ch))+" There are attempts left: "+str(self.txQueue[i]['retriesLeft'])
#                            if ts==92 and i_ch==1:
#                               print "Collision in 91,1"
                                    
                            # drop packet if retried too many time
                            if self.txQueue[i]['retriesLeft'] == 0:
                                #print "I am "+str(self.id)+"sending packet "+str((self.txQueue[i]['payload'],self.txQueue[i]['retriesLeft']))+" to "+str(self.schedule[(ts,i_ch)]['neighbor'].id)+" using cell "+str((ts,i_ch))+" There are attempts left: "+str(self.txQueue[i]['retriesLeft'])
                                #possibleInterfered=0
                                
                                #if  len(self.txQueue) == self.TSCH_QUEUE_SIZE:
                                #print "Checking if this is a possible conflicting cell..." 
                                #for mote in self.engine.motes:
                                    #if mote != self and mote != self.schedule[(ts,i_ch)]['neighbor']:
                                        #if mote.schedule.has_key((ts,i_ch)):
                                            #if mote.schedule[(ts,i_ch)]['dir']==self.DIR_TX:
                                                
#                                                print "I am "+str(self.id)+" and my neighbor is "+str(self.schedule[(ts,i_ch)]['neighbor'].id)+" .Cell  "+str((ts,i_ch))+"is also being used by mote "+str(mote.id)+" with dir "+str(mote.schedule[(ts,i_ch)]['dir'])
#                                                #print "This mote has "+str(mote.schedule[(ts,i_ch)]['neighbor'].id)+" as neighbor with dir "+str(mote.schedule[(ts,i_ch)]['neighbor'].schedule[(ts,i_ch)]['dir'])
#                                                print "RSSI from  "+str(self.schedule[(ts,i_ch)]['neighbor'].id)+" to "+str(mote.id)+" is "+str(self.schedule[(ts,i_ch)]['neighbor'].getRSSI(mote))
#                                                print "RSSI from  "+str(self.id)+" to "+str(mote.schedule[(ts,i_ch)]['neighbor'].id)+" is "+str(self.getRSSI(mote.schedule[(ts,i_ch)]['neighbor']))
                                                #if (self.schedule[(ts,i_ch)]['neighbor'].getRSSI(mote)+(-97-(-105)) >= mote.minRssi) or (self.getRSSI(mote.schedule[(ts,i_ch)]['neighbor'])+(-97-(-105)) >= mote.minRssi):
                                                #if (self.schedule[(ts,i_ch)]['neighbor'].getRSSI(mote) >= mote.minRssi) or (self.getRSSI(mote.schedule[(ts,i_ch)]['neighbor']) >= mote.minRssi):
                                                    #print "Motes "+str(self.id)+" and "+str(mote.id)+" are in range so do interfere "
                                                    #possibleInterfered=1
                                                    
#                                                else:
#                                                    print "Motes "+str(self.id)+" and "+str(mote.id)+" are not in range so do not interfere "
                                            #self.engine.macdrops_overlap+=1
                                                #assert False
                                              
                                #if possibleInterfered==1:
                                    
                                    #self.engine.macdrops_overlap+=1
                                #print "Packet DROPPED FOR MAC between "+str(self.id)+" and "+str(self.schedule[(ts,i_ch)]['neighbor'].id)
                                #print "RSSI between "
#                                print self.engine.asn
                                    
#                                if ts==47 and ch == 1:
#                                    assert False
                                    
                                
                                #assert False
                                #print "I am "+str(self.id)+"sending packet "+str((self.txQueue[i]['payload'],self.txQueue[i]['retriesLeft']))+" to "+str(self.schedule[(ts,i_ch)]['neighbor'].id)+" using cell "+str((ts,i_ch))+" There are attempts left: "+str(self.txQueue[i]['retriesLeft'])
                                    
                                    
                                #more debug
                                #print "Packet DROPPED FOR MAC between "+str(self.id)+" and "+str(self.schedule[(ts,i_ch)]['neighbor'].id)
                                #self.engine.macdrops+=1
#                                
#            				  if (self.getRSSI(self.schedule[(ts,i_ch)]['neighbor']) < self.schedule[(ts,i_ch)]['neighbor'].minRssi or self.schedule[(ts,i_ch)]['neighbor'].getRSSI(self)  < self.minRssi ):
#                                    print "They are NOT in LOS"
#                					#assert False
#            				  else:
#                				 print "They are in LOS"
                     
                                # update mote stats
                                #if ts==91 and i_ch==1:
                                    #assert False
                                #if self.id==24:   
                                #if self.pktToSend[0]['payload'][0]==24:
                                self._stats_incrementMoteStats('droppedMacRetries')
                                
                                
                                # remove packet from queue
                                self.txQueue.remove(self.pktToSend[0])
                                self.pktToSend.remove(self.pktToSend[0])
                        # end of radio activity, not waiting for anything
#                        if self.id==7:
#                            "NOOONE"
                        self.schedule[(ts,i_ch)]['waitingfor']=None
                        return
                        
                        
                        
#                        # for debug
#                        #print "DEBUGING "+str((ts,i_ch))
#                        rx = self.schedule[(ts,i_ch)]['neighbor']
#                        canbeInterfered = 0
#                        for mote in self.engine.motes:
#                            if mote == self:
#                                continue
#                            if (ts,i_ch) in mote.schedule:
#                                if mote.schedule[(ts,i_ch)]['dir'] == self.DIR_TX:
#                        
#                                    print "ERROR!"+str(mote)
#                                    print "ERROR!"+str(rx)
#                                    print "CELL !"+str((ts,i_ch))
#                                    if mote.getRSSI(rx)>rx.minRssi:
#                                        canbeInterfered = 1
#                                        print "CAN BE INTERFERED !"
#                                    else:
#                                        print "CAN NOT BE INTERFERED !"
#                        self.schedule[(ts,i_ch)]['debug_canbeInterfered'] += [canbeInterfered]
 
                        #print str((ts,i_ch))+" - "+str(self.schedule[(ts,i_ch)]['debug_canbeInterfered'])
                        #return
                        
                        
                        
                    #else:
                        #print str(self.id)+" TXDONE. Nothing to do in Ts "+str(ts)+" and channel "+str(i_ch)
                        
                        
                        
#                        # for debug
#                        ch = self.schedule[(ts,i_ch)]['ch']
#                        rx = self.schedule[(ts,i_ch)]['neighbor']
#                        canbeInterfered = 0
#                        for mote in self.engine.motes:
#                            if mote == self:
#                                continue
#                            if (ts,i_ch) in mote.schedule and ch == mote.schedule[(ts,i_ch)]['ch'] and mote.schedule[(ts,i_ch)]['dir'] == self.DIR_TX:
#                                #print "ERROR!"+str(mote)
#                                #print "ERROR!"+str(rx)
#                                if mote.getRSSI(rx)>rx.minRssi:
#                                    canbeInterfered = 1
#                        self.schedule[(ts,i_ch)]['debug_canbeInterfered'] += [canbeInterfered]
#                        return
#                    #else:
#                        #print str(self.id)+" TXDONE. Nothing to do in Ts "+str(ts)+" and channel "+str(i_ch)
    
    def radio_rxDone(self,type=None,smac=None,dmac=None,payload=None,channel=None):
        '''end of RX radio activity'''
        
        asn   = self.engine.getAsn()
        ts    = asn%self.settings.slotframeLength
        #print "RXDONE function"
        with self.dataLock:
            #tss=[row[0] for row in self.schedule.keys()]
            #assert ts in tss
            #channelsInOneTs=[row[1] for row in self.schedule.keys()]
            #print "I am "+str(self.id)+" in Ts "+str(ts)+" I have scheduled channels "+str(channelsInOneTs)+". I am at ts "+str(ts)
            
#            if smac:
#                if self.DEBUG: print "RECEIVED packet in "+str(self.id)+ " type "+str(type)+" at cell "+str((ts,channel))+" from "+str(smac.id)

            ###!!!### if self.DEBUG: print "in this "+str((ts,channel))+"I am waiting for "+str(self.schedule[(ts,channel)]['waitingfor'])
            if type=='SIXP_TYPE_MYSCHEDULE':

                if self.schedule.has_key((ts,channel)) and self.schedule[(ts,channel)]['waitingfor']==self.DIR_SHARED and self.schedule[(ts,channel)]['dir']==self.DIR_SHARED:
                    #assert channel == 0

                    
                    ###!!!### if self.DEBUG: print "Cell "+str(self.schedule[(ts,channel)])
                    ###!!!### if self.DEBUG: print "Packet "+str(type)+" "+str(dmac)+" "+str(smac)+" "+str(payload)
                    if smac:
                        # I received a packet
                        ###!!!### if self.DEBUG: print "BROADCAST RECEIVED CORRECTLY in "+str(self.id)+ " from smac "+str(smac.id)+" using cell "+str((ts,channel))
                        
                        # log charge usage
                        self._logChargeConsumed(self.CHARGE_RxData_uC)
                        
                        ###!!!### if self.DEBUG: print "I have received the payload: "+str(payload) 
                        scheduleOfNeigbor=payload[2].keys()
                        ###!!!### if self.DEBUG: print "payload: "+str(scheduleOfNeigbor)
                        ###!!!### if self.DEBUG: print "Packet Broadcast received in mote "+str(self.id)+" with payload: "+str(scheduleOfNeigbor)
                        self._updateSchedule(scheduleOfNeigbor,smac)
                        
                        self.engine.bcstReceived+=1                        
                        
                        # update schedule stats
                        self.schedule[(ts,channel)]['numRx'] += 1
                        (isACKed, isNACKed) = (True, False)
                        self.schedule[(ts,channel)]['waitingfor']=None
                        return isACKed, isNACKed
                    else:
                        # this was an idle listen
                        print "BROADCAST RECEIVED INCORRECTLY"
                        print "Idle Listening in mote "+str(self.id)       
                        # log charge usage
                        self._logChargeConsumed(self.CHARGE_Idle_uC)
                                
                        (isACKed, isNACKed) = (False, False)
                        #assert False

                        self.schedule[(ts,channel)]['waitingfor']=None
                        return isACKed, isNACKed
                            
            elif type=='TRAFFICOMIO':                
                for i_ch in range(0,self.settings.numChans):                
                    if (ts,i_ch) in self.schedule.keys() and self.schedule[(ts,channel)]['dir']!=self.DIR_SHARED:           
                        assert self.schedule[(ts,channel)]['dir']!=self.DIR_SHARED 
                        if self.schedule[(ts,i_ch)]['waitingfor']==self.DIR_RX:
                            ###!!!### if self.DEBUG: print "Cell "+str(self.schedule[(ts,i_ch)])
                            ###!!!### if self.DEBUG: print "Packet "+str(type)+" "+str(dmac)+" "+str(smac)+" "+str(payload)
                            ###!!!### if self.DEBUG: print str(self.id)+" RXDONE. It is necessary do something in Ts "+str(ts)+" and channel "+str(i_ch)+" waiting for is "+str(self.schedule[(ts,i_ch)]['waitingfor'])
                            assert self.schedule[(ts,i_ch)]['dir']==self.DIR_RX
                            assert self.schedule[(ts,i_ch)]['waitingfor']==self.DIR_RX
                            
                            if smac:
				self.numReceptions += 1
                                # I received a packet
                                ###!!!### if self.DEBUG: print str(self.id)+"THIS IS FOR ME from node "+str(smac.id)
                                # log charge usage
                                self._logChargeConsumed(self.CHARGE_RxDataTxAck_uC)
                                
                                # update schedule stats
                                self.schedule[(ts,i_ch)]['numRx'] += 1
                                
                                if self.dagRoot:
                                    # receiving packet (at DAG root)
                                    
                                    # update mote stats
                                    self._stats_incrementMoteStats('appReachesDagroot')
                                    
                                    #emunicio
                                    #if payload[0]==24:
                                    self.numPacketReceived=self.numPacketReceived+1 
                                    #if (self.engine.asn < (290*self.settings.slotframeLength)) and (self.engine.asn > (190*self.settings.slotframeLength)):
				    if (self.engine.asn < (96*self.settings.slotframeLength)) and (self.engine.asn > (63*self.settings.slotframeLength)):
                                        self.probeNumPacketReceived=self.probeNumPacketReceived+1
                                    #self.numPacketReceived1sec=self.numPacketReceived1sec+1   
                                    #print str(self.numPacketReceived1sec)+" and "+str(self.numPacketReceived)
                                    
                                    # calculate end-to-end latency
                                    self._stats_logLatencyStat(asn-payload[1])
                                    
                                    # log the number of hops
                                    #if payload[0]==24:
                                    self._stats_logHopsStat(payload[2])
                                    
                                    (isACKed, isNACKed) = (True, False)
                                    
                                    ###!!!### if self.DEBUG: print str(self.id)+" has recieved a packet: "+str(payload)
                                    
                                    
                                    self.schedule[(ts,i_ch)]['waitingfor']=None
                                    return isACKed, isNACKed
                                else:
                                    # relaying packet
                                    #if self.id==15:
                                    #print "I am 15, relaying packet. My queue L is "+str(len(self.txQueue))
                                    # count incoming traffic for each node
                                    self._otf_incrementIncomingTraffic(smac)
                                    
                                    # update the number of hops
                                    newPayload     = copy.deepcopy(payload)
                                    newPayload[2] += 1
                                    
                                    # create packet
                                    relayPacket = {
                                        'asn':         asn,
                                        'type':        type,
                                        'payload':     newPayload,
                                        'retriesLeft': self.TSCH_MAXTXRETRIES
                                    }
                                    
                                    # enqueue packet in TSCH queue
                                    isEnqueued = self._tsch_enqueue(relayPacket)
                                    
                                    if isEnqueued:
                                        
                                        # update mote stats
                                        self._stats_incrementMoteStats('appRelayed')
                                        
                                        (isACKed, isNACKed) = (True, False)
                                        
                                        self.schedule[(ts,i_ch)]['waitingfor']=None                                
                                        return isACKed, isNACKed
                                    else:
                                        #ojo
#                                        cellTh=0
#                                        alcanzables=[]
#                                        self.droppedEnqueueRelaying+=1
#                                        if self.preferredParent.id == 0:
#                                            alcanzables=self.getChildrens(self) 
#                                            print "The children of "+str(self.id)+" are "+str(alcanzables)
#                                            cellTh=len(alcanzables)
#                                            while len(alcanzables)!=0:
#                                                    hijo=alcanzables[0]
#                                                    #print len(alcanzables)
#                                                    alcanzables.remove(hijo)
#                                                    #print len(alcanzables)
#                                                    for hijodehijo in self.getChildrens(hijo):
#                                                        cellTh+=1
#                                                        alcanzables.append(hijodehijo)
#                                                    #print len(alcanzables)
#                                                    
#                                                    #print "One children of "+str(hijo.preferredParent.id)+" is "+str(hijo.id)
#                                                    
#                                        print "I am "+str(self.id)+" and my parent is 0 and I require cells: "+str(len([(ts,c['ch'],c['neighbor']) for ((ts,ch),c) in self.schedule.items() if c['dir']==self.DIR_TX]))
#                                        print "I should have cells: "+str(cellTh)
                                        
                                        self._stats_incrementMoteStats('droppedAppFailedEnqueue')
                                        (isACKed, isNACKed) = (False, True)
                                        #if relayPacket['payload'][0]==24:
                                            #print "Sending NACK"
                                        self.schedule[(ts,i_ch)]['waitingfor']=None
                                        return isACKed, isNACKed
                            else:
                                # this was an idle listen
                                ###!!!### print "I have received an illegible packet"
                                # log charge usage
                                self._logChargeConsumed(self.CHARGE_Idle_uC)
                                
                                (isACKed, isNACKed) = (False, False)
                    
                                self.schedule[(ts,i_ch)]['waitingfor']=None
                                return isACKed, isNACKed    
            
            else:
#                 if ts!=0 and channel!=0:
#                     if self.schedule[(ts,channel)]['rxDetectedCollision']==True:
#                         print "Detected collision in "+str((ts,channel))
                 #packet illegible I dont know type neither cell   
                 # this was an idle listen
                 #print "I have received an illegible packet. Not know the type"
                 #print "Packet "+str(type)+" "+str(dmac)+" "+str(smac)+" "+str(payload)+" "+str(channel)
                                # log charge usage
		 #emunicio
                 #if ts!=0:
                 	#self._logChargeConsumed(self.CHARGE_Idle_uC)
                 
		 #always coung charge
		 self._logChargeConsumed(self.CHARGE_Idle_uC)
               
                 (isACKed, isNACKed) = (False, False)
                 #print "At cell "+str((ts,channel))+" mote "+str(self.id)+" has received a illegible packet changing state "+str(self.schedule[(ts,channel)]['waitingfor'])  
                 
                 #if the broadcast packet has failed, we still can wait for a correct broadcast
                                 
                 self.schedule[(ts,channel)]['waitingfor']=None
                 
                 
                 #print " to "+str(self.schedule[(ts,channel)]['waitingfor']) 
#                 for i in range(self.settings.numChans):
#                     for j in range(self.settings.slotframeLength):
#                         if self.schedule.has_key((j,i)):
#                             self.schedule[(j,i)]['rxDetectedCollision']=False
                 #assert False
                 return isACKed, isNACKed
            
            
            
            
#            if type=='SIXP_TYPE_MYSCHEDULE':
#                for i_ch in range(0,self.settings.numChans):
#                    if self.schedule.has_key((ts,i_ch)) and self.schedule[(ts,i_ch)]['waitingfor']==self.DIR_SHARED and (ts,i_ch) == (0,0):
#                        assert i_ch == 0
#                        assert ts == 0
#                        if self.DEBUG: print "Cell "+str(self.schedule[(ts,i_ch)])
#                        if self.DEBUG: print "Packet "+str(type)+" "+str(dmac)+" "+str(smac)+" "+str(payload)
#                        if smac:
#                            # I received a packet
#                            if self.DEBUG: print "BROADCAST RECEIVED CORRECTLY in "+str(self.id)+ " from smac "+str(smac.id)
#                            # log charge usage
#                            self._logChargeConsumed(self.CHARGE_RxDataTxAck_uC)
#                            
#                            if self.DEBUG: print "I have received the payload: "+str(payload) 
#                            scheduleOfNeigbor=payload[2].keys()
#                            if self.DEBUG: print "payload: "+str(scheduleOfNeigbor)
#                            if self.DEBUG: print "Packet Broadcast received in mote "+str(self.id)+" with payload: "+str(scheduleOfNeigbor)
#                            self._updateSchedule(scheduleOfNeigbor,smac)
#                            # update schedule stats
#                            self.schedule[(0,0)]['numRx'] += 1
#                            (isACKed, isNACKed) = (True, False)
#                            self.schedule[(0,0)]['waitingfor']=None
#                            return isACKed, isNACKed
#                        else:
#                            # this was an idle listen
#                            if self.DEBUG: print "BROADCAST RECEIVED INCORRECTLY"
#                            if self.DEBUG: print "Idle Listening in mote "+str(self.id)       
#                            # log charge usage
#                            self._logChargeConsumed(self.CHARGE_Idle_uC)
#                                    
#                            (isACKed, isNACKed) = (False, False)
#                            #assert False
#                            self.schedule[(0,0)]['waitingfor']=None
#                            return isACKed, isNACKed
#                            
#            elif type=='TRAFFICOMIO':                
#                for i_ch in range(0,self.settings.numChans):                
#                    if (ts,i_ch) in self.schedule.keys() and (ts,i_ch) != (0,0):           
#                        assert (ts,i_ch) != (0,0) 
#                        if self.schedule[(ts,i_ch)]['waitingfor']==self.DIR_RX:
#                            if self.DEBUG: print "Cell "+str(self.schedule[(ts,i_ch)])
#                            if self.DEBUG: print "Packet "+str(type)+" "+str(dmac)+" "+str(smac)+" "+str(payload)
#                            if self.DEBUG: print str(self.id)+" RXDONE. It is necessary do something in Ts "+str(ts)+" and channel "+str(i_ch)+" waiting for is "+str(self.schedule[(ts,i_ch)]['waitingfor'])
#                            assert self.schedule[(ts,i_ch)]['dir']==self.DIR_RX
#                            assert self.schedule[(ts,i_ch)]['waitingfor']==self.DIR_RX
#        
#                            if smac:
#                                # I received a packet
#                                if self.DEBUG: print str(self.id)+"THIS IS FOR ME from node "+str(smac.id)
#                                # log charge usage
#                                self._logChargeConsumed(self.CHARGE_RxDataTxAck_uC)
#                                
#                                # update schedule stats
#                                self.schedule[(ts,i_ch)]['numRx'] += 1
#                                
#                                if self.dagRoot:
#                                    # receiving packet (at DAG root)
#                                    
#                                    # update mote stats
#                                    self._stats_incrementMoteStats('appReachesDagroot')
#                                    
#                                    #emunicio
#                                    self.numPacketReceived=self.numPacketReceived+1    
#                                    #self.numPacketReceived1sec=self.numPacketReceived1sec+1   
#                                    #print str(self.numPacketReceived1sec)+" and "+str(self.numPacketReceived)
#                                    
#                                    # calculate end-to-end latency
#                                    self._stats_logLatencyStat(asn-payload[1])
#                                    
#                                    # log the number of hops
#                                    self._stats_logHopsStat(payload[2])
#                                    
#                                    (isACKed, isNACKed) = (True, False)
#                                    
#                                    if self.DEBUG: print str(self.id)+" has recieved a packet: "+str(payload)
#                                    
#                                    
#                                    self.schedule[(ts,i_ch)]['waitingfor']=None
#                                    return isACKed, isNACKed
#                                else:
#                                    # relaying packet
#                                    
#                                    # count incoming traffic for each node
#                                    self._otf_incrementIncomingTraffic(smac)
#                                    
#                                    # update the number of hops
#                                    newPayload     = copy.deepcopy(payload)
#                                    newPayload[2] += 1
#                                    
#                                    # create packet
#                                    relayPacket = {
#                                        'asn':         asn,
#                                        'type':        type,
#                                        'payload':     newPayload,
#                                        'retriesLeft': self.TSCH_MAXTXRETRIES
#                                    }
#                                    
#                                    # enqueue packet in TSCH queue
#                                    isEnqueued = self._tsch_enqueue(relayPacket)
#                                    
#                                    if isEnqueued:
#                                        
#                                        # update mote stats
#                                        self._stats_incrementMoteStats('appRelayed')
#                                        
#                                        (isACKed, isNACKed) = (True, False)
#                                        
#                                        self.schedule[(ts,i_ch)]['waitingfor']=None                                
#                                        return isACKed, isNACKed
#                                    else:
#                                        #ojo
#                                        (isACKed, isNACKed) = (False, True)
#                                        
#                                        self.schedule[(ts,i_ch)]['waitingfor']=None
#                                        return isACKed, isNACKed
#                            else:
#                                # this was an idle listen
#                                print "I have received an illegible packet"
#                                # log charge usage
#                                self._logChargeConsumed(self.CHARGE_Idle_uC)
#                                
#                                (isACKed, isNACKed) = (False, False)
#                    
#                                self.schedule[(ts,i_ch)]['waitingfor']=None
#                                return isACKed, isNACKed    
#            
#            else:
#                 #packet illegible I dont know type neither cell   
#                 # this was an idle listen
#                 #print "I have received an illegible packet. Not know the type"
#                 #print "Packet "+str(type)+" "+str(dmac)+" "+str(smac)+" "+str(payload)+" "+str(channel)
#                                # log charge usage
#                 self._logChargeConsumed(self.CHARGE_Idle_uC)
#                                
#                 (isACKed, isNACKed) = (False, False)
#                 #print "At cell "+str((ts,channel))+" mote "+str(self.id)+" has received a illegible packet changing state "+str(self.schedule[(ts,channel)]['waitingfor'])  
#                 self.schedule[(ts,channel)]['waitingfor']=None
#                 #print " to "+str(self.schedule[(ts,channel)]['waitingfor']) 
#                 
#                 #assert False
#                 return isACKed, isNACKed   
                    
  
                
    
    #===== wireless
    
    def setPDR(self,neighbor,pdr):
        ''' sets the pdr to that neighbor'''
        with self.dataLock:
            self.PDR[neighbor] = pdr
    
    def getPDR(self,neighbor):
        ''' returns the pdr to that neighbor'''
        with self.dataLock:
            return self.PDR[neighbor]
    
    def setRSSI(self,neighbor,rssi):
        ''' sets the RSSI to that neighbor'''
        with self.dataLock:
            self.RSSI[neighbor.id] = rssi
    
    def getRSSI(self,neighbor):
        ''' returns the RSSI to that neighbor'''
        with self.dataLock:
            #emunicio
            if neighbor==self:
                return self.minRssi
            else:
                return self.RSSI[neighbor.id]
    
    def _estimateETX(self,neighbor):
        
        with self.dataLock:
            
            # set initial values for numTx and numTxAck assuming PDR is exactly estimated
            pdr                   = self.getPDR(neighbor)
            numTx                 = self.NUM_SUFFICIENT_TX
            numTxAck              = math.floor(pdr*numTx)
            
            for (_,cell) in self.schedule.items():
                if (cell['neighbor'] == neighbor) and (cell['dir'] == self.DIR_TX):  #ok shared cell broadcast is not taken in account
                    numTx        += cell['numTx']
                    numTxAck     += cell['numTxAck']
            
            # abort if about to divide by 0
            if not numTxAck:
                return
            
            # calculate ETX
            
            etx = float(numTx)/float(numTxAck)
            #print "I am "+str(self.id)+" my etx to "+str(neighbor.id)+" is "+str(etx)
	    #return 1
            return etx
    
    def _myNeigbors(self):
        return [n for n in self.PDR.keys() if self.PDR[n]>0]
    def _myGoodNeigbors(self):
        return [n for n in self.PDR.keys() if self.PDR[n]>0.5]
    
    #===== clock
    
    def clock_getOffsetToDagRoot(self):
        ''' calculate time offset compared to the DAGroot '''
        
        asn                  = self.engine.getAsn()
        offset               = 0.0
        child                = self
        parent               = self.preferredParent

        #print "I am "+str(self.id)+" and my correction is "+str(self.timeCorrectedSlot)
            
        i=0
        while True:
            secSinceSync     = (asn-child.timeCorrectedSlot)*self.settings.slotDuration  # sec
            # FIXME: for ppm, should we not /10^6?
            relDrift         = child.drift - parent.drift                                # ppm
            offset          += relDrift * secSinceSync    
	    i=i+1
            if i>30:
                print "I am "+str(self.id)+" and my parent is "+str(self.preferredParent)+" However the parent of my parent is "+str(self.preferredParent.preferredParent)
                assert False                               # us
            if parent.dagRoot:
                break
            else:
                child        = parent
                parent       = child.preferredParent
        
        return offset
        
    #emunicio   
    def recalculateNumHopsToRoot(self):
        ''' calculate time offset compared to the DAGroot '''
        child                = self
        parent               = self.preferredParent
        i=0
        #print "ASN "+str(self.engine.asn)
        while True:
            i=i+1
           # print i
            if i>30:
                print "I am "+str(self.id)+" and my parent is "+str(self.preferredParent.id)+" However the parent of my parent is "+str(self.preferredParent.preferredParent.id)
                print "The parent of the parent of my parent is "+str(self.preferredParent.preferredParent.preferredParent.id)
                print "The parent of the parent of the parent of my parent is "+str(self.preferredParent.preferredParent.preferredParent.preferredParent.id)
                print "The parent of the parent of the parent of the parent of my parent is "+str(self.preferredParent.preferredParent.preferredParent.preferredParent.preferredParent.id)
                print "The parent of the parent of the parent of the parent of the parent my parent is "+str(self.preferredParent.preferredParent.preferredParent.preferredParent.preferredParent.preferredParent.id)
                print "The parent of the parent of the parent of the parent of the parent of the parent of my parent is "+str(self.preferredParent.preferredParent.preferredParent.preferredParent.preferredParent.preferredParent.preferredParent.id)
                assert False 
            if parent.dagRoot:
                break
            else:
                child        = parent
                parent       = child.preferredParent
             
        return i
    #===== location
    
    def setLocation(self,x,y):
        with self.dataLock:
            self.x = x
            self.y = y
    
    def getLocation(self):
        with self.dataLock:
            return (self.x,self.y)
    
    #==== battery
    
    def boot(self):
        # start the stack layer by layer
        
        # app
        if not self.dagRoot:
#            if self.settings.numPacketsBurst!=None and self.settings.burstTimestamp!=None:
#                self._app_schedule_sendPacketBurst()
#            else:
#                self._app_schedule_sendSinglePacket(firstPacket=True)
            self._app_schedule_sendSinglePacket(firstPacket=True)
        # RPL
        self._rpl_schedule_sendDIO(firstDIO=True)
        # OTF
        self._otf_resetInboundTrafficCounters()
	#self._otf_schedule_housekeeping()
        #added in Send Dio when the tree is already formed        
        
#        if self.id!=0:
#            self._otf_schedule_housekeeping(firstOtf=True)
        
        # 6top
        if not self.settings.sixtopNoHousekeeping:
            ###!!!### if self.DEBUG: print "Configuring 6Top"
            self._sixtop_schedule_housekeeping()
        if self.settings.scheduler=='broad':
	    ###!!!### print "Simulating with broadcast and with overlapping of "+str(self.settings.overlappingBrCells)
            self._schedule_setInitialCell()
        #pause at start
            
        #firstpause=self.engine.asn+2
        #self.engine.pauseAtAsn(firstpause)
            
        #secondpause=self.engine.asn+3900   
        #self.engine.pauseAtAsn(2837)  

        # tsch
        self._tsch_schedule_activeCell()
        
      
    
    def _logChargeConsumed(self,charge):
        with self.dataLock:
            self.chargeConsumed  += charge
    
    #======================== private =========================================
    
    #===== getters
    
    def getChildrens(self,node):
        with self.dataLock:
            children=[]                                           
            for mote in self.engine.motes:
                if mote.preferredParent == node:
                    children.append(mote)
                    #print str(mote.id)+" is the son of "+str(node.id)
            #print children   
            return children   
    
    def getMyMaxCellDemand(self):
        with self.dataLock:
            alcanzables=[]
            #self.droppedEnqueueRelaying+=1
            #if self.preferredParent.id == 0:
            alcanzables=self.getChildrens(self) 
            #print "The children of "+str(self.id)+" are "+str(alcanzables)
            cellTh=len(alcanzables)+1  #+1 because I have to bear in mind my own traffic
            while len(alcanzables)!=0:
                hijo=alcanzables[0]
                #print len(alcanzables)
                alcanzables.remove(hijo)
                #print len(alcanzables)
                for hijodehijo in self.getChildrens(hijo):
                    cellTh+=1
                    alcanzables.append(hijodehijo)
            #print "Need "+str(cellTh)       
            cellTh=int((((1-self.getPDR(self.preferredParent))+1)*cellTh)+1)     
            #print "Add "+str(cellTh)  
            return cellTh
    
    def getTxCells(self):
        with self.dataLock:
            return [(ts,c['ch'],c['neighbor']) for ((ts,ch),c) in self.schedule.items() if c['dir']==self.DIR_TX]
    
    def getRxCells(self):
        with self.dataLock:
            return [(ts,c['ch'],c['neighbor']) for ((ts,ch),c) in self.schedule.items() if c['dir']==self.DIR_RX]
    def getRxCellsToNeighbor(self,neighbor):
        with self.dataLock:
            return [(ts,c['ch'],c['neighbor']) for ((ts,ch),c) in self.schedule.items() if c['dir']==self.DIR_RX and c['neighbor']==neighbor]
    def getSharedCells(self):
        with self.dataLock:
            return [(ts,c['ch'],c['neighbor']) for ((ts,ch),c) in self.schedule.items() if c['dir']==self.DIR_SHARED]
    def checkOverlapCollisionInCell(self,ts,ch):
        with self.dataLock:
            print "Testing overlap in cell "+str((ts,ch))
            if self.scheduleNeigborhood.has_key((ts,ch)):
                if self.schedule.get((ts,ch))['neighbor']!=self.scheduleNeigborhood.get((ts,ch))['neighbor']:
                    print "HEY Collision in cell "+str((ts,ch))
                    #assert  
                    return true
            return False
    #===== stats
    
    # mote state
    
    def getMoteStats(self):
        
        
        
        # gather statistics
        with self.dataLock:
            returnVal = copy.deepcopy(self.motestats)
            returnVal['numTxCells']         = len(self.getTxCells())
            returnVal['numRxCells']         = len(self.getRxCells())
            returnVal['aveQueueDelay']      = self._stats_getAveQueueDelay()
            returnVal['aveLatency']         = self._stats_getAveLatency()
            returnVal['aveHopsPackets']     = self.hopsToRoot
            returnVal['aveHops']            = self._stats_getAveHops()
            returnVal['probableCollisions'] = self._stats_getRadioStats('probableCollisions')            
            returnVal['txQueueFill']        = len(self.txQueue)
            returnVal['PKTTX']              = self.numPacketSent
            returnVal['PKTRX']              = self.numPacketReceived
            returnVal['numReqCells']        = self.numReqCells
            #returnVal['cellsLearned']       = self.numcellsLearned
            returnVal['chargeConsumed']     = self.chargeConsumed
            #returnVal['numTx']              = sum([cell['numTx'] for (_,cell) in self.schedule.items()])
            returnVal['numTx']              =self.numTransmissions
            returnVal['numRx']              =self.numReceptions
            #returnVal['cellsNotGiven']       =self.cellsNotGiven
            #returnVal['droppedEnqueueRelaying']     =self.droppedEnqueueRelaying
            returnVal['thReqCells']         =self.threq
            returnVal['txBroadcast']     = self.engine.bcstTransmitted
            returnVal['rxBroadcast']     = self.engine.bcstReceived
	    returnVal['numRandomSelections']     = self.numRandomSelections
        # reset the statistics
        self._stats_resetMoteStats()
        self._stats_resetQueueStats()
        self._stats_resetLatencyStats()
        self._stats_resetHopsStats()
        self._stats_resetRadioStats()
        
        return returnVal
    
    
#    def getMote1SecStats(self):
#        
#        # gather statistics
#        with self.dataLock:
#            returnVal = copy.deepcopy(self.mote1secstats)        
#            returnVal['OL']                 = self.numPacketSent1sec*128*8
#            returnVal['THROUGHPUT']         = self.numPacketReceived1sec*128*8
            
            
            
        #print str(self.mote1secstats)     
        # reset 1 sec statistics
        #print "OL "+str(self.mote1secstats.get('OL')) +" at ASN "+str(self.engine.getAsn())
        #self._stats_resetMote1secStats()
        
        return returnVal
    
    def _stats_resetMoteStats(self):
        with self.dataLock:
            self.motestats = {
                # app
                'appGenerated':            0,   # number of packets app layer generated
                'appRelayed':              0,   # number of packets relayed
                'appReachesDagroot':       0,   # number of packets received at the DAGroot
                'droppedAppFailedEnqueue': 0,   # dropped packets because app failed enqueue them
                # queue
                'droppedQueueFull':        0,   # dropped packets because queue is full
                # rpl
                'rplTxDIO':                0,   # number of TX'ed DIOs
                'rplRxDIO':                0,   # number of RX'ed DIOs
                'rplChurnPrefParent':      0,   # number of time the mote changes preferred parent
                'rplChurnRank':            0,   # number of time the mote changes rank
                'rplChurnParentSet':       0,   # number of time the mote changes parent set
                'droppedNoRoute':          0,   # packets dropped because no route (no preferred parent)
                # otf
                'otfAdd':                  0,   # OTF adds some cells
                'otfRemove':               0,   # OTF removes some cells
                'droppedNoTxCells':        0,   # packets dropped because no TX cells
                # 6top
                'topTxRelocatedCells':     0,   # number of time tx-triggered 6top relocates a single cell
                'topTxRelocatedBundles':   0,   # number of time tx-triggered 6top relocates a bundle
                'topRxRelocatedCells':     0,   # number of time rx-triggered 6top relocates a single cell
                # tsch
                'droppedMacRetries':       0,   # packets dropped because more than TSCH_MAXTXRETRIES MAC retries
               # 'numDeniedCells':                   0,
                'numReqCells':                   0,	
                #'droppedEnqueueRelaying':                   0,
                'thReqCells':                   0,
                'cellsNotGiven':            0,
            }
            #print self.motestats.get('PKTTX')
            
#    def _stats_resetMote1secStats(self):
#        self.mote1secstats = {
#             'Throughput':              0,
#             'OL':                      0,
#        }
#        self.numPacketReceived1sec=0
#        self.numPacketSent1sec=0
    
    def _stats_incrementMoteStats(self,name):
        with self.dataLock:
            self.motestats[name] += 1
            
    
    
    # cell stats
    
    def getCellStats(self,ts_p,ch_p):
        ''' retrieves cell stats '''
        
        returnVal = None
        with self.dataLock:
            for ((ts,ch),cell) in self.schedule.items():
                if ts==ts_p and cell['ch']==ch_p:
                    returnVal = {
                        'dir':            cell['dir'],
                        'neighbor':       cell['neighbor'].id,
                        'numTx':          cell['numTx'],
                        'numTxAck':       cell['numTxAck'],
                        'numRx':          cell['numRx'],
                    }
                    break
        return returnVal
    
    # queue stats
    
    def _stats_logQueueDelay(self,delay):
        with self.dataLock:
            self.queuestats['delay'] += [delay]
    
    def _stats_getAveQueueDelay(self):
        d = self.queuestats['delay']
        return float(sum(d))/len(d) if len(d)>0 else 0
    
    def _stats_resetQueueStats(self):
        with self.dataLock:
            self.queuestats = {
                'delay':               [],
            }
    
    # latency stats
    
    def _stats_logLatencyStat(self,latency):
        with self.dataLock:
            self.packetLatencies += [latency]
    
    def _stats_getAveLatency(self):
        with self.dataLock:
            d = self.packetLatencies
            return float(sum(d))/float(len(d)) if len(d)>0 else 0
    
    def _stats_resetLatencyStats(self):
        with self.dataLock:
            self.packetLatencies = []
    
    # hops stats
    
    def _stats_logHopsStat(self,hops):
        with self.dataLock:
            self.packetHops += [hops]
    
    def _stats_getAveHops(self):
        with self.dataLock:
            d = self.packetHops
            #print "Packet HOPS"+str(d)
            return float(sum(d))/float(len(d)) if len(d)>0 else 0
    
    def _stats_resetHopsStats(self):
        with self.dataLock:
            self.packetHops = []
    
    # radio stats
    
    def stats_incrementRadioStats(self,name):
        with self.dataLock:
            self.radiostats[name] += 1
    
    def _stats_getRadioStats(self,name):
        return self.radiostats[name]
    
    def _stats_resetRadioStats(self):
        with self.dataLock:
            self.radiostats = {
                'probableCollisions':      0,   # number of packets that can collide with another packets 
            }
    
    #===== log
    
    def _log(self,severity,template,params=()):
        
        if   severity==self.DEBUG:
            if not log.isEnabledFor(logging.DEBUG):
                return
            logfunc = log.debug
        elif severity==self.INFO:
            if not log.isEnabledFor(logging.INFO):
                return
            logfunc = log.info
        elif severity==self.WARNING:
            if not log.isEnabledFor(logging.WARNING):
                return
            logfunc = log.warning
        elif severity==self.ERROR:
            if not log.isEnabledFor(logging.ERROR):
                return
            logfunc = log.error
        else:
            raise NotImplementedError()
        
        output  = []
        output += ['[ASN={0:>6} id={1:>4}] '.format(self.engine.getAsn(),self.id)]
        output += [template.format(*params)]
        output  = ''.join(output)
        logfunc(output)
        
    def _log_printEndResults(self):
        #if not self.dagRoot:
        with self.dataLock:
            self.engine.totalRx=self.engine.totalRx+self.numReceptions
            self.engine.totalTx=self.engine.totalTx+self.numTransmissions
	    #print "HOLA"
            #else:
    #        timeElapsed=0
    #        if self.engine.timeElapsedFlow==0:
    #            timeElapsed=self.engine.timeElapsedFlow
    #            timeStampRecvTraffic_init=self.settings.slotDuration  + self.pkPeriod*self.myrand + 8
    #            timeStampRecvTraffic_end=self.settings.slotDuration*self.settings.slotframeLength*(self.settings.numCyclesPerRun-15)
    #            timeElapsed=timeStampRecvTraffic_end-timeStampRecvTraffic_init
                     
            #print "Mote "+str(self.id)+" TimeElapsed "+str(self.engine.timeElapsedFlow)+" PacketsGenerated "+str(self.packetsGenerated)
		
	    self.engine.packetsSentToRoot=self.probePacketsGenerated+self.engine.packetsSentToRoot
	    self.engine.olGeneratedToRoot=(self.probePacketsGenerated/self.engine.timeElapsedFlow)+self.engine.olGeneratedToRoot
	    self.engine.packetReceivedInRoot=self.probeNumPacketReceived+self.engine.packetReceivedInRoot
	    self.engine.thReceivedInRoot=(self.probeNumPacketReceived/self.engine.timeElapsedFlow)+self.engine.thReceivedInRoot
	    
	    if self.settings.generateIndividualSummarys == True:

            	with open('{1}/mysummary{0}_{2}_cpu{3}.ods'.format(self.settings.numMotes,self.settings.simDataDir,self.settings.scheduler,self.settings.cpuID),'a') as f:
                	f.write("Mote "+str(self.id)+" TimeElapsed "+str(self.engine.timeElapsedFlow)+" PacketsGenerated "+str(self.probePacketsGenerated)+" AvgOLgenerated: "+str(self.probePacketsGenerated/self.engine.timeElapsedFlow)+" pk/s"+" PacketsReceived "+str(self.probeNumPacketReceived)+" AvgTHReceived: "+str(self.probeNumPacketReceived/self.engine.timeElapsedFlow)+" pk/s\n")
                	if self.id==0:
                    		print "Mote "+str(self.id)+" TimeElapsed "+str(self.engine.timeElapsedFlow)+" PacketsGenerated "+str(self.probePacketsGenerated)+" AvgOLgenerated: "+str(self.probePacketsGenerated/self.engine.timeElapsedFlow)+" pk/s"+" PacketsReceived "+str(self.probeNumPacketReceived)+" AvgTHReceived: "+str(self.probeNumPacketReceived/self.engine.timeElapsedFlow)+" pk/s\n"
    #def _get_sorted_channels(self):

    def _schedule_setInitialCell(self):
        
        with self.dataLock:
            
                      
            
            for j_ch in range(0,self.settings.numChans):
            
                
                
        #        print "Mote "+str(self.id)+" my neighbors are: "
                ts_b=0
                n=0
                while n<=self.settings.numBroadcastCells-1:
                    
                    cell = (ts_b,j_ch)
                    for neighbor in self._myNeigbors():
                        if self.scheduleNeigborhood.has_key(neighbor)==False:
                            self.scheduleNeigborhood[neighbor]=[]
                        self.scheduleNeigborhood[neighbor].append(cell)
                    ###!!!### if self.DEBUG: print "Initializing neighborsSchedule "+str(self.scheduleNeigborhood)+" in mote "+str(self.id)
                    self.schedule[(ts_b,j_ch)] = {
                                'ts':                        ts_b,
                                'ch':                        j_ch,
                                'dir':                       self.DIR_SHARED,
                                'neighbor':                  self.BROAD,
                                'numTx':                     0,
                                'numTxAck':                  0,
                                'broadCell_id':              self.numBroadCells,
                                'numRx':                     0,
                                'busy':                      0,
                                'history':                   [],
                                'waitingfor':                None,
                                'rxDetectedCollision':       False,
                                'debug_canbeInterfered':     [],                      # [debug] shows schedule collision that can be interfered with minRssi or larger level 
                                'debug_interference':        [],                      # [debug] shows an interference packet with minRssi or larger level 
                                'debug_lockInterference':    [],                      # [debug] shows locking on the interference packet
                                'debug_cellCreatedAsn':      self.engine.getAsn(),    # [debug]
                            }
                    #print "Adding cell "+str( broadCell_id)
                    ###!!!### if self.DEBUG: print "Mote "+str(self.id)+" using cell ("+str((ts_b,j_ch))+") as cell for broadcasting the schedules"
                    ts_b+=int(self.settings.slotframeLength/self.settings.numBroadcastCells)
                    n+=1
                    self.numBroadCells+=1
                    
            ###!!!### print "There are broadcast cells= "+str(self.numBroadCells)       
            if self.settings.numBroadcastCells!=0:            
                
                if self.settings.overlappingBrCells==0:
                    self.maxWin=math.ceil((float(self.settings.numMotes)/self.numBroadCells))
                else:
                    assert self.settings.overlappingBrCells < 1
                    assert self.settings.overlappingBrCells > 0
                    ###!!!### if self.DEBUG: print "num motes1="+str(math.ceil(self.settings.numMotes*self.settings.overlappingBrCells))
                    ###!!!### if self.DEBUG: print "num motes2="+str(self.settings.numMotes-math.ceil(self.settings.numMotes*self.settings.overlappingBrCells))
                    ###!!!### if self.DEBUG: print "sum motes3="+str(int((self.settings.numMotes-math.ceil(self.settings.numMotes*self.settings.overlappingBrCells))/self.numBroadCells))
                    self.maxWin=int((self.settings.numMotes-math.ceil(self.settings.numMotes*self.settings.overlappingBrCells))/self.numBroadCells)
                    if self.maxWin==0:
                        self.maxWin=1
                    #self.maxWin=math.ceil((float(self.settings.numMotes)/self.broadCell_id))
                #print "There are motes is: "+str(self.settings.numMotes)
                #print "There are overlapping: "+str(self.settings.overlappingBrCells)
                #print "The maxWin would be: "+str(math.ceil((float(self.settings.numMotes-math.ceil(self.settings.numMotes*self.settings.overlappingBrCells))/self.broadCell_id)))
                ###!!!### if self.DEBUG: print "Mote "+str(self.id)+" There are motes in each broadcast cell: "+str(self.maxWin)+" and there are broadcast cells "+str(self.numBroadCells)
                #print "The window is: "+str(self.maxWin)
                #print "Mote "+str(self.id)+" has broadcast order: "+str(self.id%self.maxWin)
                #if self.id %2==0:
                
                if self.settings.overlappingBrCells==0:
                    ###!!!### if self.DEBUG: print "No overlaping in broadcast cell is expected"
                    self.numberOfWaitings= int((self.id/(self.numBroadCells)))
                    self.chosenBroadCell_id=(self.id % self.numBroadCells)
                    ###!!!### print "Mote "+str(self.id)+" using broadcast cell for broadcasting the schedules, ("+str(self.chosenBroadCell_id)+") with order: "+str(self.numberOfWaitings)
                    value=[(ts,c['ch']) for ((ts,ch),c) in self.schedule.items() if c['broadCell_id']==(self.id % (self.numBroadCells))]
                    self.myBrTs=value[0][0]
                    self.myBrCh=value[0][1]
                    ###!!!### if self.DEBUG: print "Cell "+str((self.id % (self.numBroadCells)))+" correspond to: "+str((self.myBrTs,self.myBrCh))
                else:
                    ###!!!### if self.DEBUG: print "overlaping in broadcast cell can occur!!"
                    
                    if len(self.checkIfNeighborsInThisBroadcastCell((self.id % (self.numBroadCells)),int((self.id/self.numBroadCells) % self.maxWin))) >0: 
                        ###!!!### if self.DEBUG: print "indeed occur!!"
                        ###!!!### print "I am "+str(self.id)+" and I am going to select ramdomly my broadcast cell: from 0 to "+str(self.numBroadCells-1)
                        self.numberOfWaitings=random.randint(0,self.maxWin-1)                            
                        ###!!!### print "I have selected randomly order "+str(self.numberOfWaitings)+" from "+str(0)+" to "+str(self.maxWin-1)
                        self.chosenBroadCell_id=random.randint(0,self.numBroadCells-1) 
                        ###!!!### print "Taken "+str(self.chosenBroadCell_id)+" Mote "+str(self.id)+" using broadcast cell for broadcasting the schedules, ("+str(self.chosenBroadCell_id)+") with order: "+str(self.numberOfWaitings)
                        value=[(ts,c['ch']) for ((ts,ch),c) in self.schedule.items() if c['broadCell_id']==(self.chosenBroadCell_id)]
                        self.myBrTs=value[0][0]
                        self.myBrCh=value[0][1]
                        ###!!!### print "Cell "+str(self.chosenBroadCell_id)+" correspond to: "+str((self.myBrTs,self.myBrCh))                            
                    else:
                        ###!!!### if self.DEBUG: print "false alarm"
                        self.numberOfWaitings= int((self.id/self.numBroadCells) % self.maxWin)
                        ###!!!### if self.DEBUG: print "I am "+str(self.id)+" and I am going to select Secuencially my broadcast cell"
                        self.chosenBroadCell_id=(self.id % self.numBroadCells)
                        ###!!!### print "Mote "+str(self.id)+" using broadcast cell for broadcasting the schedules, ("+str(self.chosenBroadCell_id)+") with order: "+str(self.numberOfWaitings)
                        value=[(ts,c['ch']) for ((ts,ch),c) in self.schedule.items() if c['broadCell_id']==(self.id % self.numBroadCells)]
                        self.myBrTs=value[0][0]
                        self.myBrCh=value[0][1]
                        ###!!!### if self.DEBUG: print "Cell "+str((self.id % (self.numBroadCells)))+" correspond to: "+str((self.myBrTs,self.myBrCh))
                 
#                for cellBroad in self.schedule.keys():
#                    print "Mote "+str(self.id)+" using cells for broadcast: "+str(cellBroad)
#                for neighbor in self._myNeigbors():
#                    print "Initializing neighbors"+str(neighbor.id)+" with schedule "+str(self.scheduleNeigborhood[neighbor])+" in mote "+str(self.id)   
                
    def checkIfNeighborsInThisBroadcastCell(self, broadCell_id, order):
        
        neighbors=self._myNeigbors()
        candidates=[]
        ###!!!### if self.DEBUG: print "i am "+str(self.id)+" and i want to use this broadcast cell: C "+str(broadCell_id)+" and order "+str(order)
        for neigh in neighbors:  
            if self.DEBUG: print "neighbor "+str(neigh.id)+" is using this broadcast cell: C "+str(neigh.chosenBroadCell_id)+" and order "+str(neigh.numberOfWaitings)
            if neigh.chosenBroadCell_id==broadCell_id and neigh.numberOfWaitings==order:
                if self.DEBUG: print "probable Collision!"
                candidates.append(neigh)
        ###!!!### if self.DEBUG: print "candidates that can collide "+str(len(candidates))
        return candidates        
        #print "Adding new cell"+str(self.schedule[(0,0)])+" in mote "+str(self.id)+" to "+str(self.schedule[(0,0)].get('neighbor') )
    def _updateSchedule(self,scheduleOfNeigbor,neighbor):
        
        #check if it is a real deletion, or temporal 
        #NOT VALID for mobility environments        
        
        with self.dataLock:
        
        
                #print "I am "+str(self.id)+" My schedule to this neighbor schedule. Currently is: "+str(self.scheduleNeigborhood)+" I have received: "+str(scheduleOfNeigbor)+" from the neighbor "+str(neighbor.id)
            #if neighbor in self._myNeigbors():
                #myScheduledNeighbors=[c['neighbor'].id for ((ts,ch),c) in self.schedule.items() if (ts,ch) != (0,0)]
                #if neighbor.id not in myScheduledNeighbors:
                #    print "I dont have nothing scheduled with "+str(neighbor.id)+" but is in my neighborhood. So I'm going to add it to my neighborhood schedule"
                #    self.scheduleNeigborhood[neighbor.id]=scheduleOfNeigbor
                #else:
        
        
#                print "I have neighbors: "+str(len(self.scheduleNeigborhood.keys()))
#                for neigh in self.scheduleNeigborhood.keys():
#                    print "Its me "+str(self.id)+" I have as neighbor "+str(neigh)+" an he has "+str(self.scheduleNeigborhood[neigh])
                
                if self.scheduleNeigborhood[neighbor]!=scheduleOfNeigbor:
                    #print "I am "+str(self.id)+" I am reciving a schedule that I already know: I had "+str(self.scheduleNeigborhood[neighbor])
                    #print "I am "+str(self.id)+" I am reciving a schedule that I already know: I have "+str(scheduleOfNeigbor)
#                    if self.id==12 or self.id==1 or self.id==44 or self.id==17:
#                        if neighbor.id==12 or neighbor.id==1 or neighbor.id==44 or neighbor.id==17:
                    ###!!!### if self.DEBUG: print "Not learning!! I am "+str(self.id)+" I have learnt these schedule from "+str(neighbor.id)+" I had: "+str(self.scheduleNeigborhood[neighbor])
                    ###!!!### if self.DEBUG: print "Not learning!! I am "+str(self.id)+" I have learnt these schedule from "+str(neighbor.id)+" I have: "+str(scheduleOfNeigbor)
                ###!!!### else:
                    ###!!!### if self.DEBUG: print "I am "+str(self.id)+" I have learnt these schedule from "+str(neighbor.id)+" I had: "+str(self.scheduleNeigborhood[neighbor])
                    ###!!!### if self.DEBUG: print "I am "+str(self.id)+" I have learnt these schedule from "+str(neighbor.id)+" I have: "+str(scheduleOfNeigbor)
                    self.scheduleNeigborhood[neighbor]=scheduleOfNeigbor
                
                
                
#                for neighbor in self._myNeigbors():
#                    print "I have neighbor "+str(neighbor.id)+" with schedule "+str(self.scheduleNeigborhood[neighbor])+" I am mote "+str(self.id)
#                    print "My pdr with this neighbor is "+str(self.getPDR(neighbor))
        
#                mustlearn=1
#                for (_,cell) in self.schedule.items():
#                    if cell['neighbor']==neighbor:
#                        print "I am "+str(self.id)+" I am reciving a schedule that I already know"
#                        mustlearn=0
#                if mustlearn==1:
#                    self.scheduleNeigborhood[neighbor]=scheduleOfNeigbor
#                    print "I am "+str(self.id)+" I have learnt these schedule from "+str(neighbor.id)+" : "+str(scheduleOfNeigbor)
                    
                    
                #print "And now , I have neighbors: "+str(len(self.scheduleNeigborhood.keys()))
                #for neigh in self.scheduleNeigborhood.keys():
#                    print "Its me "+str(self.id)+" I have as neighbor "+str(neigh)+" an he has "+str(self.scheduleNeigborhood[neigh])    
                    
                    
                    
            #else:
                
                #myScheduledNeighbors=[c['neighbor'].id for ((ts,ch),c) in self.schedule.items() if (ts,ch) != (0,0)]
                #if neighbor.id not in myScheduledNeighbors:
                  #  print "I dont have nothing scheduled with "+str(neighbor.id)+" and is not in my neighborhood. However I'm going to add it to my neighborhood schedule"
                 #   self.scheduleNeigborhood[neighbor.id]=scheduleOfNeigbor
                #else:
                  #  self.scheduleNeigborhood[neighbor.id]=scheduleOfNeigbor               
                    #print "I am mote "+str(self.id)+" Updated my neighbor schedule. Now is: "+str(self.scheduleNeigborhood)
